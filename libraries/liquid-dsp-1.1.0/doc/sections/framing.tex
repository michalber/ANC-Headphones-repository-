% 
% MODULE : framing
%

\newpage
\section{framing}
\label{module:framing}
The framing module contains objects and methods for packaging data into
manageable frames and packets.
For convention, \liquid\ refers to a ``packet'' as a group of binary
data bytes (often with forward error-correction applied)
that need to be communicated over a wireless link.
Objects that operate on packets in \liquid\ are the
{\tt bpacketgen}, {\tt bpacketsync} and {\tt packetizer} structures.
By contrast, a ``frame'' is a representation of the data once it has been
properly partitioned, encapsulated, and modulated before transmitting over the
air.
Framing objects included in \liquid\ are the
{\tt frame64}, {\tt flexframe}, {\tt gmskframe}, and
{\tt ofdmflexframe} structures
which greatly simplify over-the-air digital communication of raw data.


% 
% interleaver
%
\subsection{{\tt interleaver}}
\label{module:framing:interleaver}
This section describes the functionality of the \liquid\ {\tt interleaver}
object.
In wireless communications systems, bit errors are often grouped together as a
result of multi-path fading, demodulator symbol errors, and synchronizer
instability.
Interleavers serve to distribute grouped bit errors evenly throughout a block
of data which aids certain forward error-correction (FEC) codes in their
decoding process (see \S\ref{module:fec} on error-correcting codes).
On the transmit side of the wireless link, the interleaver re-orders the bits
after FEC encoding and before modulation.
On the receiving side, the de-interleaver re-shuffles the bits to their
original position before attempting to run the FEC decoder.
The bit-shuffling order must be known at both the transmitter and receiver.

The {\tt interleaver} object operates by permuting indices on the input data
sequence.
The indices are computed during the {\tt interleaver\_create()} method and
stored internally.
At each iteration data bytes are re-shuffled using the permutation array.
Depending upon the properties of the array, multiple iterations should not
result in observing the original data sequence.
Shown below is a simple example where 8 symbols ($0,\ldots,7$) are re-ordered
using a random permutation.
The data at iteration 0 are the original data which are permuted twice.
% TODO : use graphic for this...
\begin{verbatim}
    forward
    permutation     iter[0]     iter[1]     iter[2]
    0 -> 6          0           6           1
    1 -> 4          1           4           3
    2 -> 7          2           7           5
    3 -> 0          3           0           6
    4 -> 3          4           3           0
    5 -> 2          5           2           7
    6 -> 1          6           1           4
    7 -> 5          7           5           2
\end{verbatim}
%
Reversing the process is as simple as computing the reverse permutation from
the input; this is equivalent to reversing the arrows in the forward
permutation
(e.g. the $2 \rightarrow 7$ forward permutation becomes the $7 \rightarrow 2$
reverse permutation).
\begin{verbatim}
    reverse
    permutation     iter[2]     iter[1]     iter[0]
    0 -> 3          1           6           0
    1 -> 6          3           4           1
    2 -> 5          5           7           2
    3 -> 4          6           0           3
    4 -> 1          0           3           4
    5 -> 7          7           2           5
    6 -> 0          4           1           6
    7 -> 2          2           5           7
\end{verbatim}
%
Notice that permuting indices only re-orders the bytes of data and does
nothing to shuffle the bits within the byte.
It is beneficial to FEC decoders to separate the bit errors as much as
possible.
Therefore, in addition to index permutation, \liquid\ also applies masks to
the data while permuting.
% TODO : explain more

\subsubsection{Interface}
\label{module:framing:interleaver:interface}
The {\tt interleaver} object operates like most objects in \liquid\ with
typical {\tt create()}, {\tt destroy()}, and {\tt execute()} methods.

\begin{description}
\item[{\tt interleaver\_create(n)}]
    creates an interleaver object accepting $n$ bytes,
    and defaulting to 2 iterations.
\item[{\tt interleaver\_destroy(q)}]
    destroys the interleaver object, freeing all internally-allocated
    memory arrays.
\item[{\tt interleaver\_set\_num\_iterations(q,k)}]
    sets the number of iterations of the interleaver.
    Increasing the number of iterations helps improve bit dispersion, but can
    also increase execution time.
    The default number of iterations at the time of creation is 2 (see
    Figure~\ref{fig:module:framing:interleaver:scatterplot}).
\item[{\tt interleaver\_encode(q,*msg\_dec,*msg\_enc)}]
    runs the forward interleaver, reading data from the first array argument
    and writing the result to the second array argument.
    The array pointers can reference the same block of memory, if necessary.
\item[{\tt interleaver\_decode(q,*msg\_enc,*msg\_dec)}]
    runs the reverse interleaver, reading data from the first array argument
    and writing the result to the second array argument.
    Like the {\tt encode()} method, the array pointers can reference the same
    block of memory.
\end{description}
%
This listing gives a basic demonstration to the interface to the
{\tt interleaver} object:
%
\input{listings/interleaver.example.c.tex}

%-------------------- FIGURE: interleaver scatterplot --------------------
\begin{figure}
\centering
\mbox{
  \subfigure[$i=0$]
    {
      \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, height=6cm]{figures.gen/interleaver_scatterplot_i0}
      \label{fig:interleaver:scatterplot:0}
    } \quad
  \subfigure[$i=1$]
    {
      \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, height=6cm]{figures.gen/interleaver_scatterplot_i1}
      \label{fig:interleaver:scatterplot:1}
    } \quad
}
\mbox{
  \subfigure[$i=2$]
    {
      \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, height=6cm]{figures.gen/interleaver_scatterplot_i2}
      \label{fig:interleaver:scatterplot:2}
    } \quad
  \subfigure[$i=3$]
    {
      \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, height=6cm]{figures.gen/interleaver_scatterplot_i3}
      \label{fig:interleaver:scatterplot:3}
    } \quad
}
\mbox{
  \subfigure[$i=4$]
    {
      \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, height=6cm]{figures.gen/interleaver_scatterplot_i4}
      \label{fig:interleaver:scatterplot:4}
    } \quad
}
\caption{{\tt interleaver} (block) demonstration of a 64-byte (512-bit) array
with increasing number of iterations (interleaving depth)}
\label{fig:module:framing:interleaver:scatterplot}
\end{figure}
%
A visualization of the interleaver can be seen in
Figure~\ref{fig:module:framing:interleaver:scatterplot}
where the input index is plotted against the output index for varying number
of iterations.
Notice that with zero iterations, the output and input are identical (no
interleaving).
With one iteration only the bytes are interleaved, and so the output is
grouped into 8-bit blocks.
Further iterations, however, result in sufficiently dispersed bits, and
patterns between input and output indices become less evident.
%
The {\tt packetizer} object (\S\ref{module:framing:packetizer}) uses the
{\tt interleaver} object in conjunction to forward error-correction coding
(\S\ref{module:fec}) to provide a simple interface for generating
protected data packets.
A full example can be found in {\tt examples/interleaver\_example.c}.


%
% packetizer
%
\subsection{{\tt packetizer} (multi-level error-correction)}
\label{module:framing:packetizer}
The \liquid\ packetizer is a structure for abstracting multi-level forward
error-correction from the user.
The packetizer accepts a buffer of uncoded data bytes and adds a
cyclic redundancy check (CRC) before applying two levels of forward
error-correction and bit-level interleaving.
The user may choose any two supported FEC schemes (including none) and the
packetizer object will handle buffering and data management internally,
providing a truly abstract interface.
The same is true for the packet decoder which accepts an array
of possibly corrupt data and attempts to recover the original message using
the FEC schemes provided.
The packet decoder returns the validity of the resulting CRC as well as its
best effort of decoding the message.

%The {\tt packetizer} object (\S\ref{module:framing:packetizer})
%uses two {\tt fec} objects (an inner and outer code) in conjunction with an
%{\tt interleaver} object (\S\ref{module:framing:interleaver})
%and a 32-bit cyclic redundancy check.

The packetizer also allows for re-structuring if the user wishes to change
error-correction schemes or data lengths.  This is accomplished with the
{\tt packetizer\_recreate()} method.
Listed below is the full interface to the {\tt packetizer} object.
%
\begin{description}
\item[{\tt packetizer\_create(n,crc,fec0,fec1)}]
    creates and returns a {\tt packetizer} object which accepts $n$
    uncoded input bytes and uses the specified CRC and bi-level FEC
    schemes.
\item[{\tt packetizer\_recreate(q,n,crc,fec0,fec1)}]
    re-creates an existing {\tt packetizer} object with new parameters.
\item[{\tt packetizer\_destroy(q)}]
    destroys an {\tt packetizer} object, freeing all
    internally-allocated memory.
\item[{\tt packetizer\_print(q)}]
    prints the internal state of the {\tt packetizer} object to the
    standard output.
\item[{\tt packetizer\_get\_dec\_msg\_len(q)}]
    returns the specified decoded message length $n$ in bytes.
\item[{\tt packetizer\_get\_enc\_msg\_len(q)}]
    returns the fully-encoded message length $k$ in bytes.
\item[{\tt packetizer\_encode(q,*msg,*pkt)}]
    encodes the $n$-byte input message storing the result in the
    $k$-byte encoded output message.
\item[{\tt packetizer\_decode(q,*pkt,*msg)}]
    decodes the $k$-byte encoded input message storing the result in the
    $n$-byte output.
    The function returns a {\tt 1} if the internal CRC passed
    and a {\tt 0} if it failed.
    If no CRC was specified (e.g. {\tt LIQUID\_CRC\_NONE}) then a {\tt 1} is
    always returned.
\item[{\tt packetizer\_decode\_soft(q,*pkt,*msg)}]
    decodes the encoded input message just like
    {\tt packetizer\_decode()}
    but with soft bits instead of hard bytes.
    The input is an array of type {\tt unsigned char} with $8 \times k$
    elements representing soft bits.
    As before, the function returns a {\tt 1} if the internal CRC passed
    and a {\tt 0} if it failed.
    See \S\ref{module:fec:soft} for more information on
    soft-decision decoding.
\end{description}
%
Here is a minimal example demonstrating the packetizer's most basic
functionality:
%
\input{listings/packetizer.example.c.tex}
%
See also: fec module, {\tt examples/packetizer\_example.c}


%
% bpacket
%
\subsection{{\tt bpacket} (binary packet generator/synchronizer)}
\label{module:framing:bpacket}
The {\tt bpacketgen} and {\tt bpacketsync} objects realize a pair of
binary packet generator and synchronizer objects useful for streaming
data applications.
The {\tt bpacketgen} object generates packets by encapsulating data
using a {\tt packetizer} object but adds a special bit sequence and
header to the beginning of the packet.
The bit sequence at the beginning of the packet allows the synchronizer
to find it using a binary cross-correlator;
the header includes information about how the packet is encoded,
including the two levels of forward error-correction coding used, the
validity check (e.g. cyclic redundancy check), and the length of the
payload.
The full packet is assembled according to
Figure~\ref{fig:module:framing:bpacket_structure}.
% 
% FIGURE: bpacket structure
%
\begin{figure}
\centering
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=16cm]{figures.pgf/bpacket_structure}
\caption{
    Structure used for the {\tt bpacketgen} and
    {\tt bpacketsync} objects.}
\label{fig:module:framing:bpacket_structure}
\end{figure}


At the receiver
the {\tt bpacketsync} object correlates against the bit sequence looking
for the beginning of the packet.
It is important to realize that the receiver does not need to be
byte-aligned as the packet synchronizer takes care of this internally.
Once a packet has been found the packet synchronizer decodes the header
to determine how the payload is to be decoded.
The payload is decoded and the resulting data is passed to a callback
function.
The synchronizer compensates for the situation where all the bits are
flipped (e.g. coherent BPSK with a phase offset of $\pi$ radians).
Because the packet's header includes information about how to decode the
payload the synchronizer automatically reconfigures itself to the packet
parameters without any additional specification by the user.
This allows great flexibility adapting encoding parameters to dynamic
channel environments.


% bpacketgen
\subsubsection{{\tt bpacketgen} interface}
\label{module:framing:bpacket:bpacketgen}
The functionality of the {\tt bpacket} structure is split into two
objects:
the {\tt bpacketgen} object generates the packets and runs on the
transmit side of the link while
the {\tt bpacketsync} object synchronizes and decodes the packets and
runs on the receive side of the link.
Listed below is the full interface to the {\tt bpacketgen} object.
%
\begin{description}
\item[{\tt bpacketgen\_create(m,n,crc,fec0,fec1)}]
    creates and returns a {\tt bpacketgen} object which accepts $n$
    uncoded input bytes and uses the specified CRC and bi-level FEC
    schemes.
    The first parameter ($m$) is reserved for future development and is
    currently ignored.
    %The length of the p/n sequence is specified by $m$ (ignored).
\item[{\tt bpacketgen\_recreate(q,m,n,crc,fec0,fec1)}]
    re-creates an existing {\tt bpacketgen} object with new parameters.
\item[{\tt bpacketgen\_destroy(q)}]
    destroys an {\tt bpacketgen} object, freeing all
    internally-allocated memory.
\item[{\tt bpacketgen\_print(q)}]
    prints the internal state of the {\tt bpacketgen} object to the
    standard output.
\item[{\tt bpacketgen\_get\_packet\_len(q)}]
    returns the length in bytes of the fully-encoded packet.
\item[{\tt bpacketgen\_encode(q,*msg,*pkt)}]
    encodes the $n$-byte input message {\tt msg},
    storing the result in the encoded output packet {\tt pkt}.
\end{description}
%


% bpacketsync
\subsubsection{{\tt bpacketsync} interface}
\label{module:framing:bpacket:bpacketsync}
As stated before, the {\tt bpacketsync} runs on the receiver to
synchronize to and decode the incoming packets.
Listed below is the full interface to the {\tt bpacketsync} object.
%
\begin{description}
\item[{\tt bpacketsync\_create(m,callback,*userdata)}]
    creates and returns a {\tt bpacketsync} object which invokes a
    user-defined callback function, passing to it a user-defined object
    pointer.
    The first parameter ($m$) is reserved for future development and is
    currently ignored.
    %The length of the transmitted p/n sequence is specified by $m$
    %(ignored).
\item[{\tt bpacketsync\_destroy(q)}]
    destroys an {\tt bpacketsync} object, freeing all
    internally-allocated memory.
\item[{\tt bpacketsync\_print(q)}]
    prints the internal state of the {\tt bpacketsync} object to the
    standard output.
\item[{\tt bpacketsync\_reset(q)}]
    resets the internal state of the object.
\item[{\tt bpacketsync\_execute(q,*bytes,n)}]
    runs the synchronizer on $n$ bytes of received data.
\item[{\tt bpacketsync\_execute\_byte(q,byte)}]
    runs the synchronizer on a single byte of received data.
\item[{\tt bpacketsync\_execute\_sym(q,sym,bps)}]
    runs the synchronizer on a symbol with {\tt bps} bits of
    information.
\item[{\tt bpacketsync\_execute\_bit(q,bit)}]
    runs the synchronizer on a single bit.
\end{description}
%
The {\tt bpacketsync} object has a callback function which has four
arguments and looks like this:
%
\begin{Verbatim}[fontsize=\small]
    int bpacketsync_callback(unsigned char *  _payload,
                             int              _payload_valid,
                             unsigned int     _payload_len,
                             void *           _userdata);
\end{Verbatim}
%
The callback is typically defined to be {\tt static} and is passed to
the instance of {\tt bpacketsync} object when it is created.
%
\begin{description}
\item[{\tt \_payload}]
    is a pointer to the decoded bytes of payload data.
    This pointer is not static and cannot be used after returning from
    the callback function.
    This means that it needs to be copied locally for you to retain the
    data.
\item[{\tt \_payload\_valid}]
    is simply a flag to indicate if the payload passed its cyclic
    redundancy check
    (``{\tt 0}'' means invalid, ``{\tt 1}'' means valid).
    If this flag is zero then the payload most likely has errors in it.
    Some applications are error tolerant and so it is possible that the
    payload data are still useful.
    Typically, though, the payload should be discarded and a
    re-transmission request should be issued.
\item[{\tt \_payload\_len}]
    indicates the number of bytes in the {\tt \_payload} argument.
\item[{\tt \_userdata}]
    is a pointer that given to the {\tt bpacketsync} object when it was
    created.
    This pointer is passed to the callback and can represent just about
    anything.
    Typically it points to another structure and is the method
    by which the decoded header and payload data are returned to the
    program outside of the callback.
\end{description}


% 
\subsubsection{Code example}
\label{module:framing:bpacket:code_example}
%
Listed below is a basic example of of the interface to the
{\tt bpacketgen} and
{\tt bpacketsync} objects.
For a detailed example program, see
{\tt examples/bpacketsync\_example.c} under the main \liquid\ project
directory.
%
\input{listings/bpacket.example.c.tex}

% 
% frame64, flexframe
%
\subsection{{\tt frame64}, {\tt flexframe} (basic framing structures)}
\label{module:framing:frames}
\liquid\ comes packaged with two basic framing structures: {\tt frame64} and
{\tt flexframe} which can be used with little modification to transmit data
over a wireless link.
The interface for both of these objects is intended to be as simple as
possible while allowing control over some of the parameters of the system.
On the transmitter side, the appropriate frame generator object is created,
configured, and executed.
The receiver side uses an appropriate frame synchronizer object which simply
picks packets of a stream of samples, invoking a callback function for each
packet it finds.
The simplicity of the receiver is that the frame synchronizer object
automatically reconfigures itself for packets of different size, modulation
scheme, and other parameters.

\subsubsection{{\tt frame64} description}
\label{module:framing:frames:frame64}
The {\tt framegen64} and {\tt framesync64} objects implement a basic framing
structure for communicating packetized data over the air.
The {\tt framegen64} object accepts a 12-byte header and 64-byte payload and
assemble a 1280sample frame.
Internally, the frame generator encodes the header and payload each with a
Hamming(12,8) block code, 16-bit cyclic redundancy check, and modulates the
result with a QPSK modem.
The header and payload are encapsulated with special phasing sequences, and
finally the resulting symbols are interpolated using a half-rate root-raised
cosine filter (see \S\ref{module:filter:firdes:rnyquist}).

The true spectral efficiency of the frame is exactly $4/5$; 64 bytes of data
(512 bits) encoded into 640 symbols.
The {\tt frame64} structure has the advantage of simplicity but lacks the
ability for true flexibility.

\subsubsection{{\tt flexframe} description}
\label{module:framing:frames:flexframe}
The {\tt flexframegen} and {\tt flexframesync} objects are similar to their
{\tt frame[gen|sync]64} counterparts, however extend functionality to include
a number of options in structuring the frame.

\subsubsection{Framing Structures}
\label{module:framing:frames:structures}
While the specifics of the {\tt frame64} and {\tt flexframe} structures
are different,
both frames consist of six basic parts:
%
%\begin{tabular*}{0.95\textwidth}{l@{\extracolsep{\fill}}lll}
%\toprule
%{\it name}      & {\it \# symbols}  & {\it \# bytes}& {\it description}  \\
%\otoprule
%ramp up         & 64                & -             & BPSK ramp up sequence \\
%phasing pattern & 64                & -             & BSPK preamble phasing pattern \\
%p/n sequence    & 64                & -             & BPSK p/n synchronization sequence \\
%header          & 256               & 32            & QPSK, $r=1/2$-coded header \\
%payload         & 512               & 64            & QPSK, $r=1/2$-coded payload \\
%ramp down.      & 64                & -             & ramp down sequence \\
%\bottomrule
%\end{tabular*}
%
\begin{description}
\item[{\sf ramp/up}]
    gracefully increases the output signal level to avoid ``key clicking'' and
    reduce spectral side-lobes in the transmitted signal.
    Furthermore, it allows the receiver's automatic gain control unit to
    lock on to the incoming signal, preventing sharp transitions in its
    output.
\item[{\sf preamble phasing}]
    is a BPSK pattern which flips phase for each transmitted symbol
    ({\tt +1,-1,+1,-1,$\ldots$}).
    This sequence serves several purposes but primarily to help the receiver's
    symbol synchronization circuit lock onto the proper timing phase.
    [This works] because the phasing pattern maximizes the number of symbol
    transitions [reword].
\item[{\sf p/n sequence}]
    is an $m$-sequence (see \S\ref{module:sequence}) exhibiting good
    auto- and cross-correlation properties.
    %The binary sequence is modulated using BPSK so that 
    This sequence aligns the frame synchronizers to the remainder of the
    frame, telling them when to start receiving and decoding the frame header,
    as well as if the phase of the received signal needs to be reversed.
    At this point, the receiver's AGC, carrier PLL, and timing PLL should all
    have locked.
    The p/n sequence is of length 64 for both the {\tt frame64} and
    {\tt flexframe} structures (63-bit $m$-sequence with additional padded
    bit).
\item[{\sf header}]
    is a fixed-length data sequence which contains a small amount of
    information about the rest of the frame.
    The headers for the {\tt frame64} and {\tt flexframe} structures are
    vastly different and are described independently.
\item[{\sf payload}]
    is the meat of the frame, containing the raw data to be transferred across
    the link.
    For the {\tt frame64} structure, the payload is fixed at 64 bytes (hence
    its moniker), encoded using the Hamming(12,8) code
    (\S\ref{module:fec}), and modulated using QPSK.
    The {\tt flexframe} structure has a variable length payload and can be
    modulated using whatever schemes the user desires, however forward
    error-correction is executed externally.
    In both cases the synchronizer object invokes the callback upon receiving
    the payload.
\item[{\sf ramp/down}]
    gracefully decreases the output signal level as per ramp/up.
\end{description}


% 
% FIGURE: framing:structure
%
\begin{figure}
\centering
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=16cm]{figures.pgf/framing_structure}
\caption{
    Framing structure used for the {\tt frame64} and {\tt flexframe}
    objects.}
\label{fig:module:framing:structure}
\end{figure}
%
A graphical depiction of the framing signal level can be seen in
figure~\ref{fig:module:framing:structure}.
The relative lengths of each section are not necessarily to scale,
particularly as the {\tt flexframe} structure allows many of these sections to
be variable in length.
%
NOTE: while the {\tt flexframegen} and {\tt flexframesync} objects are
intended to be used in conjunction with one another, the output of
{\tt flexframegen} requires matched-filtering interpolation before the
{\tt flexframesync} object can recover the data.


\subsubsection{The Decoding Process}
\label{module:framing:frames:decoding}
Both the {\tt frame64} and {\tt flexframe} objects operate very
similarly in their decoding processes.
On the receiver, frames are pulled from a stream of input samples which
can exhibit channel impairments such as noise, sample timing offset, and
carrier frequency and phase offsets.
The receiver corrects for these impairments as best it can using various
other signal processing elements in \liquid\ and attempts to decode the
frame.
If at any time a frame is decoded (even if improperly), its appropriate
user-defined callback function is invoked.
%
%Internally, the frame synchronizers...
When seeking a frame the synchronizer initially sets its internal loop
bandwidths high for acquisition, including those for the automatic gain
control, symbol timing recovery, and carrier frequency/phase recovery.
This is known as {\em acquisition} mode, and is typical for packet-based
communications systems.
% ...
Once the p/n sequence has been found, the receiver assumes it has a
sufficient lock on the channel impairments and reduces its control loop
bandwidths significantly, moving to {\em tracking} mode.

\subsection{{\tt framesyncprops\_s} (frame synchronizer properties)}
\label{module:framing:framesyncprops_s}
Governing the behavior any frame synchronizer in \liquid\ is the
{\tt framesyncprops\_s} object.
In general the frame synchronizer open the bandwidths of their control
loops until a certain sequence has been detected;
this helps reduce acquisition time of the received signal.
After the frame has been detected the control loop bandwidths are
reduced to improve stability and reduce the possibility of losing a lock
on the signal.
Listed below is a description of the {\tt framesyncprops\_} object
members.
%
\begin{description}
\item[{\tt agc\_bw0/agc\_bw1}]
    are the respective open/closed automatic gain control bandwidths.
    The default values are $10^{-3}$ and $10^{-5}$, respectively.
\item[{\tt agc\_gmin/agc\_gmax}]
    are the respective maximum/minimum automatic gain control gain values.
    The default values are $10^{-3}$ and $10^{4}$, respectively.
\item[{\tt sym\_bw0/sym\_bw1}]
    are the respective open/closed symbol synchronizer bandwidths.
    The default values are $0.08$ and $0.05$, respectively.
\item[{\tt pll\_bw0/pll\_bw1}]
    are the respective open/closed carrier phase-locked loop bandwidths.
    The default values are $0.02$ and $0.005$, respectively.
\item[{\tt k}]
    represents the matched filter's samples per symbol;
    however this parameter is reserved for future development.
    At present this number should be equal to 2 and should not be
    changed.
\item[{\tt npfb}]
    represents the number of filters in the internal symbol timing
    recovery object's polyphase filter bank
    (see \S\ref{module:filter:symsync});
    however this parameter is reserved for future development and should
    not be changed.
    The default value is 32.
\item[{\tt m}]
    represents the matched filter's symbol delay;
    however this parameter is reserved for future development and should
    not be changed.
    the default value is 3.
\item[{\tt beta}]
    represents the matched filter's excess bandwidth factor;
    however this parameter is reserved for future development and should
    not be changed.
    the default value is 0.7.
\item[{\tt squelch\_enabled}]
    is a flag that specifies if the automatic gain control's squelch is
    enabled (see \S\ref{module:agc:squelch}).
    Enabling the squelch
    (setting {\tt squelch\_enabled} equal to {\tt 1})
    will ignore received signals below the {\tt squelch\_threshold}
    value (see below) to help prevent the receiver's control loops from
    drifting.
    Enabling the squelch is usually desirable;
    however care must be taken to properly set the threshold|ideally
    about 4~dB above the noise floor|so as not to miss frames with a
    weak signal.
    By default the squelch is {\em disabled}.
\item[{\tt autosquelch\_enabled}]
    is a flag that specifies if the automatic gain control's
    {\em auto-squelch} is enabled (see
    \S\ref{module:agc:squelch:auto}).
    In brief, the auto-squelch attempts to track the signal's power to
    automatically squelch signals 4~dB above the noise floor.
    By default the auto-squelch is disabled.
\item[{\tt squelch\_threshold}]
    is the squelch threshold value in dB
    (see \S\ref{module:agc:squelch}).
    The default value is -35.0, but the ideal value is about 4~dB above
    the noise floor.
\item[{\tt eq\_len}]
    specifies the length of the internal equalizer
    (see \S\ref{module:equalization}).
    By default the length is set to zero which disables equalization of
    the receiver.
\item[{\tt eqrls\_lambda}]
    is the recursive least-squares equalizer forgetting factor
    $\lambda$
    (see \S\ref{module:equalization:eqrls}).
    The default value is $\lambda=0.999$.
\end{description}


\subsection{{\tt framesyncstats\_s} (frame synchronizer statistics)}
\label{module:framing:framesyncstats_s}
When the synchronizer finds a frame and invokes the user-defined
callback function, a special structure is passed to the callback that
includes some useful information about the frame.
This information is contained within the {\tt framesyncstats\_s}
structure.
While useful, the information contained within the structure is not
necessary for decoding and can be ignored by the user.
Listed below is a description of the {\tt framesyncstats\_} object
members.
%
\begin{description}
\item[{\tt evm}]
    is an estimate of the received error vector magnitude in decibels of
    the demodulated header
    (see \S\ref{module:modem:digital}).
\item[{\tt rssi}]
    is an estimate of the received signal strength in dB.
    This is derived from the synchronizer's internal automatic gain
    control object (see \S\ref{module:agc}).
\item[{\tt framesyms}]
    a pointer to an array of the frame symbols (e.g. QPSK) at complex
    baseband before demodulation.
    This is useful for plotting purposes.
    This pointer is not static and cannot be used after returning from
    the callback function.
    This means that it needs to be copied locally for you to retain the
    data.
\item[{\tt num\_framesyms}]
    the length of the {\tt framesyms} pointer array.
\item[{\tt mod\_scheme}]
    the modulation scheme of the frame (see \S\ref{module:modem}).
\item[{\tt mod\_bps}]
    the modulation depth (bits per symbol) of the modulation scheme used
    in the frame.
\item[{\tt check}]
    the error-detection scheme (e.g. cyclic redundancy check)
    used in the payload of the frame (see \S\ref{module:fec}).
\item[{\tt fec0}]
    the inner forward error-correction code used in the payload
    (see \S\ref{module:fec}).
\item[{\tt fec1}]
    the outer forward error-correction code used in the payload
    (see \S\ref{module:fec}).
\end{description}
%
A simple way to display the information in an instance of
{\tt framesyncstats\_s} is to use the {\tt framesyncstats\_print()}
method.


% 
% OFDM framing
%
\subsection{{\tt ofdmflexframe} (OFDM framing structures)}
\label{module:framing:ofdmflexframe}

The {\tt ofdmflexframe} family of objects (generator and synchronizer)
realize a simple way to load data onto an OFDM physical layer
system. OFDM has several benefits over traditional ``narrowband''
communications systems such as the {\tt flexframe} objects
(\S\ref{module:framing:frames}).
These objects allow the user to abstractly specify the number of
subcarriers, their assignment (null/pilot/data), forward
error-correction and modulation scheme.
Furthermore, the framing structure includes a provision for a brief
user-defined header which can be used for source/destination
address, packet identifier, etc.

Sending data in parallel channels has some distinct advantages over
serial transmission:
equalization in the presence of multi-path channel environments is much
simpler,
inter-symbol interference can be eliminated with a properly-chosen
cyclic prefix length,
and capacity can be increased by modulating data appropriately on
subcarriers relative to their signal-to-noise ratio.
Multi-carrier systems, however, are significantly more sensitive to
carrier frequency offsets and Doppler shifts, leading to inter-carrier
interference.
OFDM can therefore be more difficult to synchronize and maintain data
fidelity in mobile environments.
To assist in synchronization, the transmitter inserts special preamble
symbols at the beginning of each frame which assist the synchronizer in
estimating the carrier frequency offset,
recovering the symbol timing, and
compensating for effects of the channel.

This section gives specifics for the OFDM flexible framing structure and
is really intended only as a reference;
for a tutorial on how to use the generator/synchronizer objects without
getting into detail, please refer to the {\em OFDM Framing} tutorial
(\S\ref{tutorial:ofdmflexframe}).

\subsubsection{Operational description}
\label{module:framing:ofdmflexframe:operation}
Like the {\tt frame64} and {\tt flexframe} structures,
the {\tt ofdmflexframe} structure consists of three main components:
the preamble, the header, and the payload.
%    
\begin{description}
\item[Preamble]
    The preamble consists of two types of phasing symbols: the \Ss\ and
    \Sl\ sequences.
    The \Ss\ symbols are necessary for coarse carrier frequency
    and timing offsets while the \Sl\ sequence is used for fine timing
    acquisition and equalizer gain estimation.  The transmitter
    generates multiple \Ss\ symbols (minimally 2, but usually 3 or more)
    and just a single \Sl\ symbol. This aligns the receiver's timing to
    that of the transmitter, signaling the start of the header.
\item[Header]
    The header consists of one or more OFDM symbols; the exact number of
    OFDM symbols depends on the number of subcarriers allocated and the
    assignment of these subcarriers (null/pilot/data). The header
    carries exactly 14 bytes of information, 6 of which are used
    internally and the remaining 8 are user-defined.
    The internal header data provide framing information to the receiver
    including the modulation, forward error-correction, and
    data validation schemes of the payload as well as its length in
    bytes. These data are encoded with a forward error-correction scheme
    and modulated onto the first several OFDM symbols.
    % currently BPSK with half-rate Golay(24,12) code
\item[Payload]
    The payload consists of zero or more OFDM symbols. Like the header,
    the exact number of OFDM symbols depends on the number of
    subcarriers allocated and the assignment of these subcarriers.
\end{description}
%
% 
% FIGURE: ofdmflexframe structure
%
\begin{figure}
\centering
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=16cm]{figures.pgf/ofdmflexframe_structure}
\caption{
    Timing structure used for the {\tt ofdmflexframegen} and
    {\tt ofdmflexframesync} objects.
    The cyclic prefix is highlighted.}
\label{fig:module:framing:ofdmflexframe_structure}
\end{figure}
%
The full frame is assembled according to
Figure~\ref{fig:module:framing:ofdmflexframe_structure}.
Notice that the \Ss\ symbols do not contain a cyclic prefix;
this is to ensure continuity between contiguous \Ss\ symbols and is
necessary to eliminate inter-symbol interference.
The single \Sl\ symbol at the end of the preamble is necessary for
timing alignment and an initial equalizer estimate.
Once the frame has been detected, the header is received and decoded.
The number of symbols in the header depends on the number of data
subcarriers allocated to each OFDM symbol.
The header includes the modulation, coding schemes, and length of the
remainder of the frame.
If the synchronizer successfully decodes the header, it will
automatically reconfigure itself to decode the payload.

\subsubsection{Subcarrier Allocation}
\label{module:framing:ofdmflexframe:subcarrier_allocation}

Subcarriers may be arbitrarily allocated into three types:
% FIXME: finish description
\begin{itemize}
\item {\tt OFDMFRAME\_SCTYPE\_NULL}:
      The {\em null} option disables this subcarrier from transmission.
      This is useful for
      spectral notching and
      guard bands
      (see Figure~\ref{fig:module:framing:ofdmflexframe_spectrum}).
      Guard bands are necessary for interpolation of the signal before
      transmission;
\item {\tt OFDMFRAME\_SCTYPE\_PILOT}:
      Pilot subcarriers are used to estimate channel impairments
      including carrier phase/frequency offsets as well as timing
      offsets.
      Pilot subcarriers are necessary for coherent demodulation in OFDM
      systems.
      The {\tt ofdmflexframe} structure requires that at least two
      subcarriers be designated as pilots.
      Performance improves if the pilots are evenly spaced and separated
      as much as possible
      (see Figure~\ref{fig:module:framing:ofdmflexframe_spectrum}),
      but the exact location of pilots is not restricted;
\item {\tt OFDMFRAME\_SCTYPE\_DATA}:
      Data subcarriers are reserved for carrying the payload of the
      frame, modulated with the desired scheme.
      The spectral efficiency of the transmission improves with more
      data subcarriers.
      The {\tt ofdmflexframe} structure requires that at least one
      subcarrier be designated for data.
\end{itemize}
%
Typically the subcarriers at the band edges are disabled to avoid
aliasing during up-conversion/interpolation.
%
The elements of $\vec{p}$ are given in the same order as the FFT input
(that is, $p_0$ holds the DC subcarrier and $p_{M/2}$ holds the
subcarrier at half the sampling frequency).
%
%The {\tt ofdmflexframegenprops\_init\_default(*props)} interface
The {\tt ofdmframe\_init\_default\_sctype(M,*p)} interface
initializes the subcarrier allocation array $\vec{p}$
for a system with $M$ channels that is expected to perform relatively
well under a variety of channel conditions.
% 
% FIGURE: ofdmflexframe spectrum
%
\begin{figure}
\centering
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=16cm]{figures.pgf/ofdmflexframe_spectrum}
\caption{
    Example spectral response for the
    {\tt ofdmflexframegen} and
    {\tt ofdmflexframesync} objects.}
\label{fig:module:framing:ofdmflexframe_spectrum}
\end{figure}
%
Figure~\ref{fig:module:framing:ofdmflexframe_spectrum} depicts an
example spectral response of the {\tt ofdmflexframe} structure
with evenly-spaced pilot subcarriers, guard bands, and a spectral notch
in the lower band.
%Pilot subcarriers may be ...
%As an example, the following subcarrier allocation for an OFDM frame
%with $M=64$ subcarriers would give the spectrum shown in
%Figure~\ref{fig:module:framing:ofdmflexframe_spectrum} where
%``{\tt .}'' denotes a {\tt NULL}  subcarrier,
%``{\tt |}'' denotes a {\tt PILOT} subcarrier, and
%``{\tt +}'' denotes a {\tt DATA}  subcarrier:
%\begin{Verbatim}[fontsize=\small]
%    .+|+++|+++|+++|+++|+++|+++|+.........+|+++|+++|+.........+|+++|+
%\end{Verbatim}
%%
%The spectrum after the FFT shift:
%%
%\begin{Verbatim}[fontsize=\small]
%    .....+|+++|+++|+.........+|+++|+.+|+++|+++|+++|+++|+++|+++|+....
%\end{Verbatim}


\subsubsection{Pilot Subcarriers}
\label{module:framing:ofdmflexframe:pilots}
Pilot subcarriers are used to assist the synchronizer in tracking to
slowly-varying channel impairments such as
moderate to low carrier frequency/phase offsets
and slowly-varying timing frequency offsets
(residual error from initial estimation).
The pilots themselves are BPSK symbols with a pseudo-random phase
generated by a linear feedback shift register. % generator poly?
To improve the peak-to-average power ratio, the pilots are different not
only from one symbol to another, but within each OFDM symbol.



\subsubsection{{\tt ofdmflexframegen}}
\label{module:framing:ofdmflexframe:gen}
%
The {\tt ofdmflexframegen} object is responsible for assembling raw data
bytes into contiguous OFDM time-domain symbols which the
{\tt ofdmflexframesync} object can receive.
The life cycle of the generator is as follows:
%
\begin{enumerate}
\item create the frame generator, passing the number of subcarriers,
      cyclic prefix length, subcarrier allocation, and framing
      properties (modulation scheme, forward error-correction
      coding, payload length, etc);
\item assemble a frame consisting of raw header and payload bytes;
\item write the OFDM symbols (time series) to a buffer until the entire
      frame has been generated;
\item repeat the ``assemble'' and ``write symbol'' steps for as many
      frames as is desired;
\item destroy the frame generator object.
\end{enumerate}
%
This listing gives a basic demonstration to the interface to the
{\tt ofdmflexframegen} object:
%
\input{listings/ofdmflexframegen.example.c.tex}
%
Listed below is the full interface to the {\tt ofdmflexframegen}
object.
%
% FIXME: complete description
%
\begin{description}
%
\item[{\tt ofdmflexframegen\_create(M,c,*p,*fgprops)}]
    creates and returns an {\tt ofdmflexframegen} object
    with $M$ subcarriers ($M$ must be an even integer),
    a cyclic prefix length of $c$ samples,
    a subcarrier allocation determined by $\vec{p}$,
    and a set of properties determined by {\tt fgprops}.
%
\item[{\tt ofdmflexframegen\_destroy(q)}]
    destroys an {\tt ofdmflexframegen} object, freeing all
    internally-allocated memory.
%
\item[{\tt ofdmflexframegen\_reset(q)}]
    resets the {\tt ofdmflexframegen} object, including all internal
    buffers.
%
\item[{\tt ofdmflexframegen\_print(q)}]
    prints the internal state of the {\tt ofdmflexframegen} object.
%
\item[{\tt ofdmflexframegen\_is\_assembled(q)}]
    returns a flag indicating if the frame has been assembled yet
    ({\tt 1} if yes, {\tt 0} if no).
%
\item[{\tt ofdmflexframegen\_setprops(q,props)}]
    sets the configurable properties of the frame generator, including
    the number of \Ss\ symbols,
    the length of the payload (in bytes),
    the error-detection scheme (e.g. {\tt LIQUID\_CRC\_24}),
    the error-correction scheme(s) (e.g. {\tt LIQUID\_FEC\_HAMMING128}),
    and the modulation scheme/depth (e.g. {\tt LIQUID\_MODEM\_QPSK}).
%
\item[{\tt ofdmflexframegen\_getframelen(q)}]
    returns the number of OFDM symbols (not samples) in the frame,
    including the preamble, header, and payload.
%
\item[{\tt ofdmflexframegen\_assemble(q,*header,*payload,n)}]
    assembles the OFDM frame, internal to the {\tt ofdmflexframegen}
    object; with an 8-byte header, and an $n$-byte payload.
    Unlike the {\tt flexframegen} object, samples are not written to a
    buffer at this point, but are generated with the
    {\tt writesymbol()} method, below.
%
\item[{\tt ofdmflexframegen\_writesymbol(q,*buffer,*num\_written)}]
    writes OFDM symbols (time series) to the buffer, specifies the
    number of samples that have been written, and returns a flag
    indicating if this symbol is the last in the frame.
    All symbols are $M+c$ samples long except the \Ss\ symbols which are
    just $M$ samples long.
    Therefore the buffer only needs to hold at most $M+c$ samples.
%
\end{description}


\subsubsection{{\tt ofdmflexframesync}}
\label{module:framing:ofdmflexframe:sync}
%
The {\tt ofdmflexframesync} object is responsible for detecting frames
generated by the {\tt ofdmflexframesync} object, decoding the header and
payloads, and passing the results back to the user by way of a callback
function.
%
This listing gives a basic demonstration to the interface to the
{\tt ofdmflexframegen} object:
%
\input{listings/ofdmflexframesync.example.c.tex}
%
Notice that the input buffer can be any length, regardless of the
synchronizer object's properties.
Listed below is the full interface to the {\tt ofdmflexframesync}
object.
%
\begin{description}
%
\item[{\tt ofdmflexframesync\_create(M,c,*p,*callback,*userdata)}]
    creates and returns an {\tt ofdmflexframegen} object
    with $M$ subcarriers ($M$ must be an even integer),
    a cyclic prefix length of $c$ samples,
    a subcarrier allocation determined by $\vec{p}$,
    a user-defined callback function (see description, below)
    and user-defined data pointer.
%
\item[{\tt ofdmflexframesync\_destroy(q)}]
    destroys an {\tt ofdmflexframesync} object, freeing all
    internally-allocated memory.
%
\item[{\tt ofdmflexframesync\_print(q)}]
    prints the internal properties of the {\tt ofdmflexframesync}
    object to the standard output.
%
\item[{\tt ofdmflexframesync\_reset(q)}]
    resets the internal state of the {\tt ofdmflexframesync} object.
%
\item[{\tt ofdmflexframesync\_execute(q,*buffer,n)}]
    runs the synchronizer on an input buffer with $n$ samples of type
    {\tt float complex}.
    Whenever a frame is found and decoded, the synchronizer will invoke
    the callback function given when created.
    The input buffer can be any length, irrespective of any of the
    properties of the frame.
%
\item[{\tt ofdmflexframesync\_get\_rssi(q)}]
    queries the frame synchronizer for the received signal strength of
    the input (given in decibels).
%
\end{description}
%
%
%
The callback function for the {\tt ofdmflexframesync} object has seven
arguments and looks like this:
%
\begin{Verbatim}[fontsize=\small]
    int ofdmflexframesync_callback(unsigned char *  _header,
                                   int              _header_valid,
                                   unsigned char *  _payload,
                                   unsigned int     _payload_len,
                                   int              _payload_valid,
                                   framesyncstats_s _stats,
                                   void *           _userdata);
\end{Verbatim}
%
The callback is typically defined to be {\tt static} and is passed to
the instance of {\tt ofdmflexframesync} object when it is created.
The return value can be ignored for now and is reserved for future
development.
Here is a brief description of the callback function's arguments:
%
\begin{description}
\item[{\tt \_header}]
    is a volatile pointer to the 8 bytes of decoded user-defined header
    data from the frame generator.
\item[{\tt \_header\_valid}]
    is simply a flag to indicate if the header passed its cyclic
    redundancy check.
    If the check fails then the header data have been corrupted beyond
    the point that internal error correction can recover;
    in this situation the payload cannot be recovered.
\item[{\tt \_payload}]
    is a volatile pointer to the decoded payload data.
    When the header cannot be decoded ({\tt \_header\_valid == 0})
    this value is set to {\tt NULL}.
\item[{\tt \_payload\_len}]
    is the length (number of bytes) of the payload array.
    When the header cannot be decoded ({\tt \_header\_valid == 0})
    this value is set to {\tt 0}.
\item[{\tt \_payload\_valid}]
    is simply a flag to indicate if the payload passed its cyclic
    redundancy check
    (``{\tt 0}'' means invalid, ``{\tt 1}'' means valid).
    As with the header,
    if this flag is zero then the payload almost certainly contains
    errors.
\item[{\tt \_stats}]
    is a synchronizer statistics construct
    ({\tt framesyncstats\_s})
    that indicates some useful PHY information to the user
    (see \S\ref{module:framing:framesyncstats_s}).
\item[{\tt \_userdata}]
    is the {\tt void} pointer given to the
    {\tt ofdmflexframesync\_create()} method.
    Typically this pointer is a vehicle for getting the header and
    payload data (as well as any other pertinent information)
    back to your main program.
\end{description}
%

\subsubsection{Performance}
\label{module:framing:ofdmflexframe:performance}
%

% 
% FIGURE: ofdmflexframe performance
%
\begin{figure}
\centering
  \includegraphics[trim = 0mm 6mm 0mm 8mm, clip, width=13cm]{figures.gen/ofdmflexframesync_performance}
\caption{Performance of the {\tt ofdmflexframe} structure with
         $M=64$ subcarriers (default allocation).}
\label{fig:module:framing:ofdmflexframe_performance}
\end{figure}
%
Figure~\ref{fig:module:framing:ofdmflexframe_performance} shows the
performance characteristics of the {\tt ofdmflexframe} structure for
$M=64$ subcarriers with default subcarrier allocation.
The frame can be detected with a 90\% probability with an SNR level of
just -0.4~dB.
Furthermore, the probability of detecting the frame and decoding the
header reaches 90\% at just 2.6~dB SNR.
Decoding the remainder of the frame depends on many factors such as the
modulation scheme and forward error-correction schemes applied.
%
Here are a few general guidelines for good performance:
\begin{enumerate}
\item Equalization improves with more subcarriers, but the carrier
      frequency offset requirements have tighter restrictions;
\item While the interface supports nearly any number of subcarriers
      desired, synchronization greatly improves with at least $M=32$
      active (pilot/data) subcarriers;
\item More pilot subcarriers can improve performance in low SNR 
      environments at the penalty of reduced throughput
      (fewer subcarriers are allocated for data);
\item Increasing the cyclic prefix is really only necessary for high
      multi-path environment with a large delay spread.
      Capacity can be increased for most short-range applications by
      reducing the cyclic prefix to 4 samples, regardless of the number
      of subcarriers;
\item Most hardware have highly non-linear RF front ends (mixers,
      amplifiers, etc.) which require a transmit power back-off by a few
      dB to ensure linearity, particularly when many subcarriers are
      used.
\end{enumerate}
%
