% 
% MODULE : filter
%

\newpage
\section{filter}
\label{module:filter}
The filter module is at the core of \liquid's digital signal processing
functionality.
Filter design and implementation is a significant portion of radio
engineering, and consumes a considerable portion of the baseband receiver's
energy.
%For linear digital modulation techniques (see \S\ref{module:modem}),
%the matched filter is responsible for limiting the occupied bandwidth of the
%transmitted signal while eliminating inter-symbol interference.
%
This section includes interface descriptions for all of the signal
processing elements in \liquid\ regarding filter design and
implementation.
This includes both infinite and finite (recursive and non-recursive)
filters, decimators, interpolators, and performance characterization.


% 
% autocorr
%
\subsection{{\tt autocorr} (auto-correlator)}
\label{module:filter:autocorr}
The {\tt autocorr} family of objects implement auto-correlation of
signals.
The discrete auto-correlation of a signal $\vec{x}$
is a delay, conjugate multiply, and accumulate operation defined as
%
% TODO check this equation
\begin{equation}
\label{eqn:filter:autocorr}
    r_{xx}(n) = \sum_{k=0}^{N-1} {x(n-k)x^*(n-k-d)}
\end{equation}
%
where $N$ is the window length, and $d$ is the overlap delay.
An example of the {\tt autocorr} interface is listed below.
%
\input{listings/autocorr.example.c.tex}
%
A more detailed example is given in
{\tt examples/autocorr\_cccf\_example.c}
in the main \liquid\ project directory.
%
Listed below is the full interface to the {\tt autocorr} family of
objects.
While each method is listed for {\tt autocorr\_cccf}, the same
functionality applies to {\tt autocorr\_rrrf}.
%
\begin{description}
\item[{\tt autocorr\_cccf\_create(N,d)}]
    creates and returns an {\tt autocorr} object with a window size of
    $N$ samples and a delay of $d$ samples.
\item[{\tt autocorr\_cccf\_destroy(q)}]
    destroys an {\tt autocorr} object, freeing all internally-allocated
    memory.
\item[{\tt autocorr\_cccf\_clear(q)}]
    clears the internal {\tt autocorr} buffers.
\item[{\tt autocorr\_cccf\_print(q)}]
    prints the internal state of the {\tt autocorr} object.
\item[{\tt autocorr\_cccf\_push(q,x)}]
    pushes a sample $x$ into the internal buffer of an {\tt autocorr}
    object.
\item[{\tt autocorr\_cccf\_execute(q,*rxx)}]
    executes the delay, conjugate multiply, and accumulate operation,
    storing the result in the output variable $r_{xx}$.
\item[{\tt autocorr\_cccf\_get\_energy(q)}]
    returns $(1/N)\sum_{k=0}^{N-1}{|x(n-k)x^*(n-k-d)|}$
\end{description}



% 
% decim
%
\subsection{{\tt decim} (decimator)}
\label{module:filter:decim}
The {\tt decim} object family implements a basic interpolator with an
integer output-to-input resampling ratio $D$.
It is essentially just a {\tt firfilt} object which operates on a block
of samples at a time.
An example of the decimator can be seen in
Figure~\ref{fig:module:filter:decim_crcf}.
%
\begin{figure}
\centering
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_decim_crcf}
\caption{{\tt decim\_crcf} (decimator) example with $D=4$,
         compensating for filter delay.}
\label{fig:module:filter:decim_crcf}
\end{figure}
%
Listed below is the full interface to the {\tt decim} family of
objects.
While each method is listed for {\tt decim\_crcf}, the same
functionality applies to {\tt decim\_rrrf} and {\tt decim\_cccf}.
%
\begin{description}
\item[{\tt decim\_crcf\_create(D,*h,N)}]
    creates a {\tt decim} object with a decimation factor $D$ using $N$
    filter coefficients $\vec{h}$.
\item[{\tt decim\_crcf\_create\_prototype(D,m,As)}]
    creates a {\tt decim} object from a prototype filter with a
    decimation factor $D$,
    a delay of $Dm$ samples, and
    a stop-band attenuation $A_s$~dB.
\item[{\tt decim\_crcf\_create\_rnyquist(type,D,m,beta,dt)}]
    creates a {\tt decim} object from a square-root Nyquist prototype filter with a
    decimation factor $D$,
    a delay of $Dm$ samples,
    an excess bandwidth factor $\beta$, and
    a fractional sample delay $\Delta t$
    (see \S\ref{module:filter:firdes:rnyquist} for details).
\item[{\tt decim\_crcf\_destroy(q)}]
    destroys a {\tt decim} object, freeing all internally-allocated
    memory.
\item[{\tt decim\_crcf\_print(q)}]
    prints the parameters of a {\tt decim} object to the standard
    output.
\item[{\tt decim\_crcf\_clear(q)}]
    clears the internal buffer of a {\tt decim} object.
\item[{\tt decim\_crcf\_execute(q,*x,*y,k)}]
    computes the output decimation of the input sequence $\vec{x}$
    (which is $D$ samples in size) at the index $k$ and stores the
    result in $y$.
\end{description}
%
An example of the {\tt decim} interface is listed below.
%
\input{listings/decim.example.c.tex}
%
A more detailed example is given in
{\tt examples/decim\_crcf\_example.c}
in the main \liquid\ project directory.


% 
% firfarrow
%
\subsection{{\tt firfarrow} (finite impulse response Farrow filter)}
\label{module:filter:firfarrow}
\liquid\ implements non-recursive Farrow filters using the
{\tt firfarrow} family of objects.
The Farrow structure is convenient for varying the group delay of a
filter.
The filter coefficients themselves are not stored explicitly, but are
represented as a set of polynomials each with an order $Q$.
The coefficients can be computed dynamically from the polynomial by
arbitrarily specifying the fractional sample delay $\mu$.
%
Listed below is the full interface to the {\tt firfarrow} family of
objects.
While each method is listed for {\tt firfarrow\_crcf}, the same
functionality applies to {\tt firfarrow\_rrrf}.
%
\begin{description}
\item[{\tt firfarrow\_crcf\_create(N,Q,fc,As)}]
    creates a {\tt firfarrow} object with $N$ coefficients using a
    polynomial of order $Q$ with a cutoff frequency $f_c$ and as
    stop-band attenuation of $A_s$~dB.
\item[{\tt firfarrow\_crcf\_destroy(q)}]
    destroy object, freeing all internally-allocated memory.
\item[{\tt firfarrow\_crcf\_clear(q)}]
    clear filter internal memory buffer.
    This does not reset the delay.
\item[{\tt firfarrow\_crcf\_print(q)}]
    prints the filter's internal state to {\tt stdout}.
\item[{\tt firfarrow\_crcf\_push(q,x)}]
    push a single sample $x$ into the filter's internal buffer.
\item[{\tt firfarrow\_crcf\_set\_delay(q,mu)}]
    set fractional delay $\mu$ of filter.
\item[{\tt firfarrow\_crcf\_execute(q,*y)}]
    computes the output sample, storing the result in $y$.
\item[{\tt firfarrow\_crcf\_get\_length(q)}]
    returns length of the filter (number of taps)
\item[{\tt firfarrow\_crcf\_get\_coefficients(q,*h)}]
    returns the internal filter coefficients, storing the result in the
    output vector $\vec{h}$.
\item[{\tt firfarrow\_crcf\_freqresponse(q,fc,*H)}]
    computes the complex response $H$ of the filter at the normalized
    frequency $f_c$.
\item[{\tt firfarrow\_crcf\_groupdelay(q,fc)}]
    returns the group delay of the filter at the normalized
    frequency $f_c$.
\end{description}
%
Listed below is an example of the {\tt firfarrow} object's
interface.
%
\input{listings/firfarrow_crcf.example.c.tex}
%
An example of the Farrow filter's group delay can be found in
Figure~\ref{fig:module:filter:firfarrow_groupdelay}.
%
\begin{figure}
\centering
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_firfarrow_groupdelay}
\caption{{\tt firfarrow\_crcf} (Farrow filter) group delay example
    with $N=19$, $Q=5$, $f_c=0.45$, and $A_s=60$~dB.}
\label{fig:module:filter:firfarrow_groupdelay}
\end{figure}
%



%
% firfilt
%
\subsection{{\tt firfilt} (finite impulse response filter)}
\label{module:filter:firfilt}
Finite impulse response (FIR) filters are implemented in \liquid\ with
the {\tt firfilt} family of objects.
FIR filters (also known as {\em non-recursive filters}) operate on
discrete-time samples, computing the output $y$ as the convolution of
the input $\vec{x}$ with the filter coefficients $\vec{h}$ as
%
\begin{equation}
\label{eqn:filter:firfilt}
    y(n) = \sum_{k=0}^{N-1}{ h(k) x(N-k-1) }
\end{equation}
%
where $\vec{h} = [h(0),h(1),\ldots,h(N-1)]$
is the filter impulse response.
Notice that the output sample in (\ref{eqn:filter:firfilt})
is simply the vector dot product (see \S\ref{module:dotprod})
of the filter coefficients $\vec{h}$ with the time-reversed sequence
$\vec{x}$.
%
\begin{figure}
\centering
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_firfilt_crcf_time}
\caption{{\tt firfilt\_crcf} (finite impulse response filter) demonstration}
\label{fig:module:filter:firfilt_crcf}
\end{figure}
%
An example of the {\tt firfilt} can be seen in
Figure~\ref{fig:module:filter:firfilt_crcf}
in which a low-pass filter is applied to a signal to remove a
high-frequency component.
%
An example of the {\tt firfilt} interface is listed below.
%
\input{listings/firfilt.example.c.tex}
%
Listed below is the full interface to the {\tt firfilt} family of
objects.
While each method is listed for {\tt firfilt\_crcf}, the same
functionality applies to {\tt firfilt\_rrrf} and {\tt firfilt\_cccf}.
%
\begin{description}
\item[{\tt firfilt\_crcf\_create(*h,N)}]
    creates a {\tt firfilt} object with $N$ filter coefficients
    $\vec{h}$.
\item[{\tt firfilt\_crcf\_recreate(q,*h,N)}]
    re-creates a {\tt firfilt} object $q$ with $N$ filter coefficients
    $\vec{h}$;
    if the length of the filter doesn't change, the internal state is
    preserved.
\item[{\tt firfilt\_crcf\_destroy(q)}]
    destroys a {\tt firfilt} object, freeing all internally-allocated
    memory.
\item[{\tt firfilt\_crcf\_print(q)}]
    prints the parameters of a {\tt firfilt} object to the standard
    output.
\item[{\tt firfilt\_crcf\_clear(q)}]
    clears the internal buffer of a {\tt firfilt} object.
\item[{\tt firfilt\_crcf\_push(q,x)}]
    pushes an input sample $x$ into the internal buffer of the filter
    object.
\item[{\tt firfilt\_crcf\_execute(q,*y)}]
    generates the output sample $y$ by computing the vector dot product
    (see \S\ref{module:dotprod})
    between the internal filter coefficients and the internal buffer.
\item[{\tt firfilt\_crcf\_get\_length(q)}]
    returns the length of the filter.
\item[{\tt firfilt\_crcf\_freqresponse(q,fc,*H)}]
    returns the response of the filter at the frequency $f_c$, stored in
    the pointer $H$.
\item[{\tt firfilt\_crcf\_groupdelay(q,fc)}]
    returns the group delay of the filter at the frequency $f_c$.
\end{description}
%



% 
% firpfb
%
%\subsection{{\tt firpfb} (finite impulse response polyphase filter bank)}

% 
% firdes (finite impulse response filter design)
%
\subsection{{\tt firdes} (finite impulse response filter design)}
\label{module:filter:firdes}
This section describes the finite impulse response filter design
capabilities in \liquid.
This includes basic low-pass filter design using the windowed-$\sinc$
method,
square-root Nyquist filters,
arbitrary design using the Parks-McClellan algorithm,
and some useful miscellaneous functions.

\subsubsection{Window prototype}
\label{module:filter:firdes:window}
The ideal low-pass filter has a rectangular response in the frequency
domain and an infinite $\sin(t)/t$ response in the time domain.
Because all time-dependent filters must be causal, this type of filter
is unrealizable;
furthermore, truncating its response results in poor pass-band ripple
stop-band rejection.
An improvement over truncation is offered by use of a band-limiting
window.
Let the finite impulse response of a filter be defined as
% 
\begin{equation}
\label{eqn:filter:firdes:windowed_sinc}
    h(n) = h_i(n) w(n)
\end{equation}
%
where $w(n)$ is a time-limited symmetric window and
$h_i(n)$ is the impulse response of the ideal filter with a cutoff
frequency $\omega_c$, viz.
%
\begin{equation}
\label{eqn:filter:firdes:sinc}
    h_i(n) =    \frac{\omega_c}{\pi}
                \left(
                    \frac{\sin\omega_c n}{\omega_c n}
                \right),
                \,\,\,\,
                \forall n
\end{equation}
%
A number of possible windows could be used;
the Kaiser window is particularly common due to its systematic ability
to trade transition bandwidth for stop-band rejection.
The Kaiser window is defined as
%
\begin{equation}
\label{eqn:filter:firdes:kaiser_window}
    w(n) =  \frac{
                I_0\left[\pi\alpha\sqrt{1-\left(\frac{n}{N/2}\right)^2}\right]
            }{
                I_0\left(\pi\alpha\right)
            }
            \,\,\,\,
            -N/2 \leq n \leq N/2,
            \,\,
            \alpha \geq 0
\end{equation}
%
where $I_\nu(z)$ is the modified Bessel function of the first kind of
order $\nu$ and $\alpha$ is a shape parameter controlling the window
decay.
%
$I_\nu(z)$ can be expanded as
%
\begin{equation}
\label{eqn:filter:firdes:besseli_infinite_sum}
    I_\nu(z) =  \left( \frac{z}{2} \right)^\nu
                \sum_{k=0}^{\infty}{
                    \frac{
                        \left(\frac{1}{4}z^2\right)^k
                    }{
                        k!\Gamma(k+\nu+1)
                    }
                }
\end{equation}
%
The sum in (\ref{eqn:filter:firdes:besseli_infinite_sum})
converges quickly due to the denominator increasing rapidly, 
(and in particular for $\nu=0$ the denominator reduces to $(k!)^2$)
and thus only a few terms are necessary for sufficient approximation.
%
The sum (\ref{eqn:filter:firdes:besseli_infinite_sum}) converges quickly
due to the denominator increasing rapidly, thus only a few terms are
necessary for sufficient approximation.
For more approximations to $I_0(z)$ and $I_\nu(z)$,
see \S\ref{module:math} in the math module.
%
Kaiser gives an approximation for the value of $\alpha$ to give a
particular sidelobe level for the window as
\cite[(3.2.7)]{Vaidyanathan:1993}
\begin{equation}
\label{eq:kaiser_alpha}
    \alpha =
    \begin{cases}
        0.1102 (A_s - 8.7)      &   A_s > 50 \\
        0.5842 (A_s - 21)^{0.4} &   21 < A_s \le 50 \\
        0                       &   \text{else}
    \end{cases}
\end{equation}
%
where $A_s > 0$ is the stop-band attenuation in decibels.
%
This approximation is provided in \liquid\ by the
{\tt kaiser\_beta\_As()} method,
and the length of the filter can be approximated with
{\tt estimate\_req\_filter\_len()}
(see \S\ref{module:filter:misc} for more detail on these methods).

The entire design process is provided in \liquid\ with the
{\tt firdes\_kaiser\_window()} method which can be invoked as follows:
%
\begin{Verbatim}[fontsize=\small]
    liquid_firdes_kaiser(_n, _fc, _As, _mu, *_h)
\end{Verbatim}
%
where
{\tt \_n} is the length of the filter (number of samples),
{\tt \_fc} is the normalized cutoff frequency ($0 \leq f_c \leq 0.5$),
{\tt \_As} is the stop-band attenuation in dB ($A_s > 0$),
{\tt \_mu} is the fractional sample offset ($-0.5 \leq \mu \leq 0.5$),
and {\tt *\_h} is the $n$-sample output coefficient array.
%
Listed below is an example of the {\tt firdes\_kaiser\_window}
interface.
%
\input{listings/firdes_kaiser.example.c.tex}
%
\begin{figure}
\centering
\subfigure[time] {
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_kaiser_time}
}
\subfigure[PSD] {
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_kaiser_freq}
}
\caption{{\tt firdes\_kaiser\_window()} demonstration, $f_c=0.15$,
         $\Delta f=0.05$, $A_s=60$dB}
\label{fig:module:filter:firdes_kaiser}
\end{figure}
%
An example of a low-pass filter design using the Kaiser window can be
found in Figure~\ref{fig:module:filter:firdes_kaiser}.


\subsubsection{{\tt liquid\_firdes\_nyquist()} (Nyquist filter design)}
\label{module:filter:firdes:nyquist}
Nyquist's criteria for designing a band-limited filter without
inter-symbol interference is for the spectral response of a linear phase
filter to be symmetric about its symbol rate.
%
\liquid\ provides several Nyquist filters as design prototypes and are
listed in Table~\ref{tab:filter:nyquist}.
%
% ------------ TABLE: NYQUIST PROTOTYPES ------------
\begin{table*}
\caption{Nyquist filter prototypes available in \liquid}
\label{tab:filter:nyquist}
\centering
{\small
\begin{tabular*}{0.75\textwidth}{l@{\extracolsep{\fill}}l}
\toprule
{\it scheme} &
{\it description}\\\otoprule
%
{\tt LIQUID\_NYQUIST\_KAISER}       & Kaiser filter\\
{\tt LIQUID\_NYQUIST\_PM}           & Parks-McClellan algorithm\\
{\tt LIQUID\_NYQUIST\_RCOS}         & raised cosine\\
{\tt LIQUID\_NYQUIST\_FEXP}         & flipped exponential \cite{Beaulieu:2001}\\
{\tt LIQUID\_NYQUIST\_FSECH}        & flipped hyperbolic secant \cite{Assalini:2004}\\
{\tt LIQUID\_NYQUIST\_FARCSECH}     & flipped hyperbolic arc-secant \cite{Assalini:2004}\\\bottomrule
\end{tabular*}
}
\end{table*}%
% ------------------------
%
The interface for designing Nyquist filters is simply
%
\begin{Verbatim}[fontsize=\small]
    liquid_firdes_nyquist(_ftype, _k, _m, _beta, _dt, *h);
\end{Verbatim}
%
where {\tt \_ftype} is one of the filter types in
Table~\ref{tab:filter:nyquist},
$k$ is the number of samples per symbol,
$m$ is the filter delay in symbols,
$\beta$ is the excess bandwidth (rolloff) factor,
$\Delta t$ is the fractional sample delay (usually set to zero for
  typical filter designs
  and is ignored in the {\tt LIQUID\_NYQUIST\_PM} design),
and $h$ is the output coefficients array of length $2km+1$.
%

\subsubsection{{\tt liquid\_firdes\_rnyquist()} (square-root Nyquist filter design)}
\label{module:filter:firdes:rnyquist}
Square-root Nyquist filters are commonly used in digital communications
systems with linear modulation as a pulse shape for matched filtering.
Applying a pulse shape to the transmitted symbol sequence limits its
occupied spectral bandwidth by smoothing the transitions between
symbols.
If an identical filter is applied at the receiver then the system is
matched resulting in the maximum signal-to-noise ratio
and (theoretically) zero inter-symbol interference.
%The application of two square-root Nyquist filters results in 
%
While the design of Nyquist filters is trivial and can be accomplished
by applying any desired window to a $\sinc$ function,
designing a square-root Nyquist filter is not as straightforward.
\liquid\ conveniently provides several square-root Nyquist filter
prototypes listed in Table~\ref{tab:filter:rnyquist}.
%
% ------------ TABLE: RNYQUIST PROTOTYPES ------------
\begin{table*}
\caption{Square-root Nyquist filter prototypes available in \liquid}
\label{tab:filter:rnyquist}
\centering
{\small
\begin{tabular*}{0.75\textwidth}{l@{\extracolsep{\fill}}l}
\toprule
{\it scheme} &
{\it description}\\\otoprule
%
{\tt LIQUID\_RNYQUIST\_ARKAISER}    & approximate r-Kaiser\\
{\tt LIQUID\_RNYQUIST\_RKAISER}     & r-Kaiser\\
{\tt LIQUID\_RNYQUIST\_RRCOS}       & square-root raised cosine\\
{\tt LIQUID\_RNYQUIST\_hM3}         & harris-Moerder type 3 \cite{harris-Moerder:2005}\\
{\tt LIQUID\_RNYQUIST\_GMSTX}       & GMSK transmit filter \cite{Proakis:2001}\\
{\tt LIQUID\_RNYQUIST\_GMSRX}       & GMSK receive filter\\
{\tt LIQUID\_RNYQUIST\_FEXP}        & flipped exponential \cite{Beaulieu:2001}\\
{\tt LIQUID\_RNYQUIST\_FSECH}       & flipped hyperbolic secant \cite{Assalini:2004}\\
{\tt LIQUID\_RNYQUIST\_FARCSECH}    & flipped hyperbolic arc-secant \cite{Assalini:2004}\\\bottomrule
\end{tabular*}
}
\end{table*}%
% ------------------------
%
The interface for designing square-root Nyquist filters is simply
%
\begin{Verbatim}[fontsize=\small]
    liquid_firdes_rnyquist(_ftype, _k, _m, _beta, _dt, *h);
\end{Verbatim}
%
where {\tt \_ftype} is one of the filter types in
Table~\ref{tab:filter:rnyquist},
$k$ is the number of samples per symbol,
$m$ is the filter delay in symbols,
$\beta$ is the excess bandwidth (rolloff) factor,
$\Delta t$ is the fractional sample delay (usually set to zero for
  typical filter designs),
and $h$ is the output coefficients array of length $2km+1$.
All square-root Nyquist filters in \liquid\ have these four basic
properties ($k$, $m$, $\beta$, $\Delta t$) and produce a filter with
$N=2km+1$ coefficients.
%

The most common square-root Nyquist filter design in digital
communications is the square-root raised-cosine (RRC) filter,
likely due to the fact that an expression for its time series can be
expressed in closed form.
The filter coefficients themselves are derived from the following
equation:
%
\begin{equation}
\label{eqn:filter:rrcos}
    h\left[z\right] =
      4\beta \frac{ \cos\left[(1+\beta)\pi z\right] +
                    \sin\left[(1-\beta)\pi z\right] / (4\beta z) }
                  { \pi \sqrt{T}\left[ 1-16\beta^2z^2\right] }
\end{equation}
%
where $z=n/k-m$, and $T=1$ for most cases.
\liquid\ compensates for the two cases where $h[n]$ might be
undefined in the above equation, i.e.
%
\begin{equation}
\label{eqn:filter:rrcos:limit1}
    \mathop {\lim }\limits_{z \to 0 } h(z) = 1 - \beta + 4\beta/\pi
\end{equation}
%
and
%
\begin{equation}
\label{eqn:filter:rrcos:limit2}
    \mathop {\lim }\limits_{z \to \pm \frac{1}{4\beta} } h(z) =
        \frac{\beta}{\sqrt{2}}
        \left[
            \left(1 + \frac{2}{\pi}\right)\sin\left(\frac{\pi}{4\beta}\right) +
            \left(1 - \frac{2}{\pi}\right)\cos\left(\frac{\pi}{4\beta}\right)
        \right]
\end{equation}

The $r$-Kaiser and harris-Moerder-3 (hM3) filters cannot be expressed in
closed form but rely on iterations over traditional filter design
techniques to search for the design parameters which minimize the
resulting filter's inter-symbol interference (ISI).
Similarly the approximate $r$-Kaiser filter uses an approximation for
the design parameters to eliminate the need for running the search;
this comes at the expense of a slight performance degradation.

\begin{figure}
\centering
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_rnyquist}
\caption{Contrast of the different square-root Nyquist filters
         available in \liquid\ for
         $k=2$, $m=9$, $\beta=0.3$, and $\Delta t = 0$.}
\label{fig:module:filter:rnyquist}
\end{figure}
%
Figure~\ref{fig:module:filter:rnyquist} contrasts the different
square-root Nyquist filters available in \liquid.
The square-root raised-cosine filter is inferior to the
(approximate) $r$-Kaiser and harris-Moerder-3 filters in both transition
bandwidth as well as side-lobe suppression.
In the figure the responses of the $r$-Kaiser and approximate $r$-Kaiser
filters are indistinguishable.


\subsubsection{GMSK Filter Design}
\label{module:filter:firdes_gmsk}

%
The transmit filter for a GMSK modem with a bandwidth-time product $BT$
(equivalent to the excess bandwidth factor $\beta$) is defined as
\begin{equation}
\label{eqn:filter:gmsktx}
    h_t(t) = Q\left( \frac{2 \pi BT}{\sqrt{\ln(2)}} \left(t-\frac{1}{2}\right) \right) -
             Q\left( \frac{2 \pi BT}{\sqrt{\ln(2)}} \left(t+\frac{1}{2}\right) \right)
\end{equation}
%
where $Q(z)=\frac{1}{2}\left(1 - \erf(z/\sqrt{2})\right)$
(see \S\ref{module:math:transcendentals:Q}).
%
The transmit filter imparts inter-symbol interference, leaving the
receiver to compensate.
\liquid\ implements a GMSK receive filter by minimizing the inter-symbol
interference of the composite, and as such
there is no closed-form solution for the GMSK receive filter.
%
% FIGURE : GMSK FILTERS
\begin{figure}
\centering
\subfigure[time] {
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_firdes_gmskrx_time}
}
\subfigure[PSD] {
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_firdes_gmskrx_freq}
}
\caption{{\tt liquid\_firdes\_gmskrx()} demonstration,
         $k=4$ samples/symbol, $m=5$ symbols, BT$=0.3$}
\label{fig:module:filter:firdes_gmskrx}
\end{figure}
%
Figure~\ref{fig:module:filter:firdes_gmskrx} depicts the transmit,
receive, and composite filters in both the time and frequency domains.
Notice that the frequency response of the receive filter has a gain in
the pass-band (around $f=0.13$) to compensate for the ISI imparted by
the transmit filter.
Consequently the composite filter has nearly zero ISI,
as can be seen by its flat pass-band response
and transition through $20\log_{10}\left(\frac{1}{2}\right)$.

\subsubsection{{\tt firdespm} (Parks-McClellan algorithm)}
\label{module:filter:firdespm}
FIR filter design using the Parks-McClellan algorithm is implemented in
\liquid\ with the {\tt firdespm} interface.
The Parks-McClellan algorithm uses the Remez exchange algorithm to solve
the minimax problem (minimize the maximum error) for filter design.
The interface accepts a description of $N_b$ disjoint and
non-overlapping frequency bands with a desired response and relative
error weighting for each, and computes the resulting filter
coefficients.
%
\begin{Verbatim}[fontsize=\small]
    firdespm_run(_h_len,        // filter length
                 _bands*,       // array of frequency bands
                 _des*,         // desired response in each band
                 _weights*,     // relative weighting for each band
                 _num_bands,    // number of bands
                 _btype,        // filter type
                 _wtype*,       // weighting function for each band
                 _h*)
\end{Verbatim}
%
\begin{description}
\item[{\tt \_bands}]
    is a $[N_b \times 2]$ matrix of the band edge descriptions.
    Each row corresponds to an upper and lower band edge for each region
    of interest.
    These regions cannot be overlapping.
\item[{\tt \_des}]
    is an array of size $N_b$ with the desired response (linear) for
    each band.
\item[{\tt \_weights}]
    is an array of size $N_b$ with the relative error weighting for each
    band.
\item[{\tt \_num\_bands}]
    represents $N_b$, the number of bands in the design.
\item[{\tt \_btype}]
    gives the filter type for the design.
    This is typically {\tt LIQUID\_FIRDESPM\_BANDPASS} for the majority
    of filters.
\item[{\tt \_wtype}]
    is an array of length $N_b$ which specifies the weighting function
    for each band (flat, exponential, or linear).
\end{description}
%
Listed below is an example of the {\tt firdespm} interface.
%
\input{listings/firdespm.example.c.tex}


% firdespm
\begin{figure}
\centering
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_firdespm}
\caption{{\tt firdespm} multiple pass-band filter design demonstration}
\label{fig:module:filter:firdespm}
\end{figure}

\subsubsection{Miscellaneous functions}
\label{module:filter:misc}
Here are several miscellaneous functions used in \liquid's filter module,
useful to filtering and filter design.

\begin{description}
\item[{\tt estimate\_req\_filter\_len(df,As)}]
    returns an estimate of the required filter length, given a transition
    bandwidth $\Delta f$ and stop-band attenuation $A_s$.
%    The estimate uses Hermann's formula \cite{Herrmann:1973}
%    %
%    \begin{equation}
%    \label{eqn:filter:firdes:misc:estimate_N}
%        N \approx \frac{
%                D_{\infty}(\delta_1,\delta_2) - f(\delta_1,\delta_2)(\Delta f)^2
%            }{
%                \Delta f
%            }
%    \end{equation}
%    %
%    where
%    \[
%        D_{\infty} (\delta_1,\delta_2) =
%            \Bigl(0.005309 t_1^2 + 0.07114 t_1 - 0.4761 \Bigr) t_2
%           -\Bigl(0.00266  t_1^2 + 0.5941  t_1 + 0.4278 \Bigr)
%    \]
%    and
%    \[
%        f(\delta_1,\delta_2) = 11.012 + 0.51244\left(t_1 - t_2\right)
%    \]
%    with $t_1 = \log_{10}\delta_1$ and $t_2 = \log_{10}\delta_2$.
    The estimate uses Kaiser's formula \cite{Vaidyanathan:1993}
    %
    \begin{equation}
    \label{eqn:filter:firdes:misc:estimate_N}
        N \approx \frac{
                A_s - 7.95
            }{
                14.26 \Delta f
            }
    \end{equation}
    %

\item[{\tt estimate\_req\_filter\_As(df,N)}]
    returns an estimate of the filter's stop-band attenuation $A_s$
    given the filter's length $N$ and transition bandwidth $\Delta f$.
    The estimate uses an iterative binary search to find $A_s$ from
    {\tt estimate\_req\_filter\_As()}.

\item[{\tt estimate\_req\_filter\_df(As,N)}]
    returns an estimate of the filter's transition bandwidth $\Delta f$
    given the filter's length $N$ and stop-band attenuation $A_s$.
    The estimate uses an iterative binary search to find $\Delta f$ from
    {\tt estimate\_req\_filter\_As()}.

\item[{\tt kaiser\_beta\_As(As)}]
    % TODO : Kaiser window parameter previously defined as alpha!
    returns an estimate of the Kaiser $\beta$ factor for a particular
    stop-band attenuation $A_s$.
    The estimate uses Kaiser's original formula \cite{Vaidyanathan:1993}, viz
    %
    \begin{equation}
    \label{eqn:filter:firdes:misc:kaiser_beta}
        \beta =
        \begin{cases}
            0.1102 (A_s - 8.7)      &   A_s > 50 \\
            0.5842 (A_s - 21)^{0.4} &   21 < A_s \le 50 \\
            0                       &   \text{else}
        \end{cases}
    \end{equation}

\item[{\tt fir\_group\_delay(*h,n,f)}]
    computes the group delay for a finite impulse-response filter with
    $n$ coefficients $\vec{h}$ at a frequency $f$.
    The group delay $\tau_g$ at frequency $f$
    for a finite impulse response filter of length $N$
    is computed as
    %
    \begin{equation}
    \label{eqn:filter:firdes:misc:fir_group_delay}
        \tau_g = \Re\Biggl\{ \,\,
            \frac{
                \sum_{k=0}^{N-1}{h(k)e^{j 2 \pi f k} \cdot k}
            } {
                \sum_{k=0}^{N-1}{h(k)e^{j 2 \pi f k}}
            }\,\,
            \Biggr\}
    \end{equation}

\item[{\tt iir\_group\_delay(*b,nb,*a,na,f)}]
    computes the group delay for an infinite impulse-response filter
    with $n_a$ feed-back coefficients $\vec{a}$,
    and $n_b$ feed-forward coefficients $\vec{b}$
    at a frequency $f$.
    The group delay $\tau_g$ at frequency $f$ for an infinite impulse
    response filter of order $N$ is computed as
    % N = n_a-1 = n_b-1 ?
    %
    \begin{equation}
    \label{eqn:filter:firdes:misc:iir_group_delay}
        \tau_g = \Re\Biggl\{ \,\,
            \frac{
                \sum_{k=0}^{2(N+1)}{c(k)e^{j 2 \pi f k} \cdot k}
            } {
                \sum_{k=0}^{2(N+1)}{c(k)e^{j 2 \pi f k}}
            }\,\,
            \Biggr\}
            - N
    \end{equation}
    %
    where $c(n) = \sum_{m=0}^{N-1}{a^*(m) b(m-n)}$
    for $n \in \{0,1,\ldots,2(N+1)\}$
    which can be described as the flipped convolution of $\vec{a}$ and
    $\vec{b}$.

\item[{\tt iirdes\_isstable(*b,*a,n)}]
    checks the stability of an infinite impulse-response filter with $n$
    feed-back and feed-forward coefficients $\vec{a}$ and $\vec{b}$
    respectively.
    Stability is tested by computing the roots of the denominator
    (poles) and ensuring that they lie within the unit circle.
    Notice that the poles in
    % using the cleveref package
%    \cref{fig:module:filter:butter,%
%          fig:module:filter:cheby1,%
%          fig:module:filter:cheby2,%
%          fig:module:filter:ellip,%
%          fig:module:filter:bessel}
    % using regular references
    Figures~\ref{fig:module:filter:butter}--%
           \ref{fig:module:filter:bessel}
    all have their poles within the unit circle and are therefore stable
    (as expected).

\item[{\tt liquid\_filter\_autocorr(*h,N,n)}]
    computes the auto-correlation of a filter with an array of
    coefficients $\vec{h}$ of length $N$ at a specific lag $n$ as
    %
    \begin{equation}
    \label{eqn:filter:firdes:misc:autocorr}
        r_{hh}(n) = \sum_{k=n}^{N-1} {h(k)h^*(k-n)}
    \end{equation}

\item[{\tt liquid\_filter\_isi(*h,k,m,*rms,*max)}]
    computes the inter-symbol interference 
    (both mean-squared error and maximum error)
    for a filter $\vec{h}$ with $k$ samples per symbol and delay of $m$
    samples.
    The filter has $2km+1$ coefficients and the resulting
    RMS and maximum ISI are stored in {\tt rms} and {\tt max},
    respectively.
    This is useful in comparing the performance of root-Nyquist matched
    filter designs (e.g. root raised-cosine).
    %The inter-symbol interference of a filter is simply its auto-correlation
    %at a lag equal to its...
    %The total interference is the ...

\item[{\tt liquid\_filter\_energy(*h,N,fc,nfft)}]
    computes the relative out-of-band energy $E_0$ at a cutoff frequency
    $f_c$ for a finite impulse response filter $\vec{h}$ with $N$
    coefficients.
    The parameter {\tt nfft} specifies the precision of the computation.
    The relative out-of-band energy is computed as
    %
    \begin{equation}
    \label{eqn:filter:firdes:misc:filter_energy}
        E_0 =
            \frac{
                \int_{2 \pi f_c}^{\infty}{H(\omega)d\omega}
            } {
                \int_{0}^{\infty}{H(\omega)d\omega}
            }
    \end{equation}

\end{description}


% 
% firhilb
%
\subsection{{\tt firhilbf} (finite impulse response Hilbert transform)}
\label{module:filter:firhilb}
The {\tt firhilbf} object in \liquid\ implements a finite impulse
response Hilbert transform which
converts between real and complex time series.
The interpolator takes a complex time series and produces real-valued
samples at twice the sample rate.
The decimator reverses the process by halving the sample rate of a
real-valued time series to a complex-valued one.

Typical trade-offs between filter length, side-lobe suppression, and
transition bandwidth apply.
The {\tt firhilbf} object uses a half-band filter to implement the
transform as efficiently as possible.
While any filter length can be accepted, the {\tt firhilbf} object
internally forces the length to be of the form $n=4m+1$
to reduce the computational load.
A half-band filter of this length has $2m$ zeros and $2m+1$ non-zero
coefficients.
Of these non-zero coefficients, the center is exactly $1$ while the other $2m$
are even symmetric, and therefore only $m$ computations are needed.
%
\begin{figure}
\centering
\subfigure[time] {
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_firhilb_decim_crcf_time}
}
\subfigure[PSD] {
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_firhilb_decim_crcf_freq}
}
\caption{{\tt firhilbf} (Hilbert transform) decimator demonstration.
         The small signal at $f=0.13$ is due to aliasing as a result of
         imperfect image rejection.}
\label{fig:module:filter:firhilb}
\end{figure}
%
A graphical example of the Hilbert decimator can be seen in
Figure~\ref{fig:module:filter:firhilb}
where a real-valued input sinusoid is converted into a complex sinusoid
with half the number of samples.
%
An example code listing is given below.
Although {\tt firhilbf} is a placeholder for both
decimation (real to complex) and
interpolation (complex to real),
separate objects should be used for each task.
%
\input{listings/firhilb.example.c.tex}
%
Listed below is the full interface to the {\tt firhilbf} family of
objects.
%
\begin{description}
\item[{\tt firhilbf\_create(m,As)}]
    creates a {\tt firhilbf} object with a filter semi-length of $m$
    samples (equal to the delay)
    and a stop-band attenuation of $A_s$~dB.
    The value of $m$ must be at least 2.
    The internal filter has a length $4m+1$ coefficients and is designed
    using the {\tt firdes\_kaiser\_window()} method
    (see \S\ref{module:filter:firdes:window} on FIR filter design
    using windowing functions).
\item[{\tt firhilbf\_destroy(q)}]
    destroys the Hilbert transform object, freeing all
    internally-allocated memory.
\item[{\tt firhilbf\_print(q)}]
    prints the internal properties of the object to the standard
    output.
\item[{\tt firhilbf\_clear(q)}]
    clears the internal transform buffers.
\item[{\tt firhilbf\_r2c\_execute(q,x,*y)}]
    executes the real-to-complex transform as a half-band filter,
    rejecting the negative frequency band.
    The input $x$ is a real sample;
    the output $y$ is complex.
\item[{\tt firhilbf\_c2r\_execute(q,x,*y)}]
    executes the complex-to-real conversion as $y = \Re\{x\}$.
\item[{\tt firhilbf\_decim\_execute(q,*x,*y)}]
    executes the transform as a decimator, converting a 2-sample input
    array $\vec{x}$ of real values into a single complex output value
    $y$.
\item[{\tt firhilbf\_interp\_execute(q,x,*y)}]
    executes the transform as a decimator, converting a single complex
    input sample $x$ into a two real-valued samples stored in the output
    array $\vec{y}$.
\end{description}
%
For more detailed examples on Hilbert transforms in \liquid,
refer to the files
{\tt examples/firhilb\_decim\_example.c} and
{\tt examples/firhilb\_interp\_example.c}
located within the main \liquid\ project directory.
%
{\it See also:} {\tt resamp2} (\S\ref{module:filter:resamp2}),
FIR filter design (\S\ref{module:filter:firdes}).



% 
% iirfilt
%
\subsection{{\tt iirfilt} (infinite impulse response filter)}
\label{module:filter:iirfilt}
The {\tt iirfilt\_crcf} object and family implement the infinite impulse
response (IIR) filters.
Also known as recursive filters, IIR filters allow a portion of the output to
be fed back into the input, thus creating an impulse response which is
non-zero for an infinite amount of time.
Formally, the output signal $y[n]$ may be written in terms of the input signal
$x[n]$ as
%
\begin{equation}
\label{eqn:filter:iirfilt:y}
    y[n] = \frac{1}{a_0} \left(
           \sum_{j=0}^{n_b-1}{ b_j x[n-j] } -
           \sum_{k=1}^{n_a-1}{ a_k y[n-k] }
           \right)
\end{equation}
%
where $\vec{b} = [b_0,b_1,\ldots,b_{n_b-1}]^T$ are the feed-forward parameters
and   $\vec{a} = [a_0,a_1,\ldots,a_{n_a-1}]^T$ are the feed-back parameters
of length $n_b$ and $n_a$, respectively.
The $z$-transform of the transfer function is therefore
%
\begin{equation}
\label{eqn:filter:iirfilt:Hz}
    H(z) = \frac{Y(z)}{X(z)}
         = \frac{\sum\limits_{j=0}^{n_b-1}{b_j z^{-j}}}
                {\sum\limits_{k=0}^{n_a-1}{a_k z^{-k}}}
         = \frac{ b_0 + b_1 z^{-1} + \cdots + b_{n_b-1} z^{n_b-1}}
                { a_0 + a_1 z^{-1} + \cdots + a_{n_a-1} z^{n_a-1}}
\end{equation}
%
Typically the coefficients in $H(z)$ are normalized such that $a_0=1$.

For larger order filters (even as small as $n\approx 8$) the filter can become
unstable due to finite machine precision.
It is often therefore useful to express $H(z)$ in terms of second-order
sections.
For a filter of order $n$, these sections are denoted by the two
$(L+r)\times 3$ matrices $\vec{B}$ and $\vec{A}$
where $r=n \mod 2$ (0 for odd $n$, 1 for even $n$) and $L=(n-r)/2$.
%
\begin{equation}
\label{eqn:filter:iirfilt:Hdz}
    H_d(z) = 
             \left[
                \frac{B_{r,0} + B_{r,1}z^{-1}}
                     {1       + A_{r,1}z^{-1}}
             \right]^r
             \prod_{k=1}^{L} {\left[
                \frac{B_{k,0} + B_{k,1}z^{-1} + B_{k,2}z^{-2}}
                     {1       + A_{k,1}z^{-1} + A_{k,2}z^{-2}}
             \right]}
\end{equation}
%
Notice that $H(z)$ is now a series of cascaded second-order IIR filters.
The `sos' form is practical when filters are designed from analog prototypes
where the poles and zeros are known.
\liquid\ implements second-order sections efficiently with the internal
{\tt iirfiltsos\_crcf} family of objects.
For a cascaded second-order section IIR filter, use
{\tt iirfilt\_crcf\_create\_sos(B,A,n)}.
%
{\em See also}: {\tt iirdes} (IIR filter design) in
\S\ref{module:filter:iirdes}.

Listed below is the full interface to the {\tt iirfilt} family of
objects.
The interface to the {\tt iirfilt} object follows the convention of
other \liquid\ signal processing objects;
while each method is listed for {\tt iirfilt\_crcf}, the same
functionality applies to {\tt iirfilt\_rrrf} and {\tt iirfilt\_cccf}.
%
\begin{description}
\item[{\tt iirfilt\_crcf\_create(*b,Nb,*a,Nb)}]
    creates a new {\tt iirfilt} object with
    $N_b$ feed-forward coefficients $\vec{b}$ and
    $N_a$ feed-back coefficients $\vec{a}$.
\item[{\tt iirfilt\_crcf\_create\_sos(*B,*A,Nsos)}]
    creates a new {\tt iirfilt} object using $N_{sos}$ second-order
    sections.
    The $[N_{sos} \times 3]$ feed-forward coefficient matrix is
    specified by $\vec{B}$ and
    the $[N_{sos} \times 3]$ feed-back coefficient matrix is
    specified by $\vec{A}$.
\item[{\tt iirfilt\_crcf\_create\_prototype(ftype,btype,format,order,fc,f0,Ap,As)}]
    creates a new IIR filter object using the prototype interface
    described in \S\ref{module:filter:iirdes:iirdes}.
    This is the simplest method for designing an IIR filter with
    Butterworth, Chebyshev-I, Chebyshev-II, elliptic/Cauer, or Bessel
    coefficients.
\item[{\tt iirfilt\_crcf\_destroy(q)}]
    destroys an {\tt iirfilt} object, freeing all internally-allocated memory
    arrays and buffers.
\item[{\tt iirfilt\_crcf\_print(q)}]
    prints the internals of an {\tt iirfilt} object.
\item[{\tt iirfilt\_crcf\_clear(q)}]
    clears the filter's internal state.
\item[{\tt iirfilt\_crcf\_execute(q,x,*y)}]
    executes one iteration of the filter with an input $x$, storing the
    result in $y$, and updating its internal state.
\item[{\tt iirfilt\_crcf\_get\_length(q)}]
    returns the order of the filter.
\item[{\tt iirfilt\_crcf\_freqresponse(q,fc,*H)}]
    computes the complex response $H$ of the filter at the normalized
    frequency $f_c$.
\item[{\tt iirfilt\_crcf\_groupdelay(q,fc)}]
    returns the group delay of the filter at the normalized
    frequency $f_c$.
\end{description}
%
Listed below is a basic example of the interface.
For more detailed and extensive examples, refer to
{\tt examples/iirfilt\_crcf\_example.c}
in the main \liquid\ project source directory.
%
\input{listings/iirfilt.example.c.tex}
%
\begin{figure}
\centering
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_iirfilt_crcf_time}
\caption{
    {\tt iirfilt\_crcf} (infinite impulse response filter)
    example.}
\label{fig:module:filter:iirfilt_crcf}
\end{figure}
%
An example of the {\tt iirfilt} can be seen in
Figure~\ref{fig:module:filter:iirfilt_crcf}
in which a low-pass filter is applied to a signal to remove a
high-frequency component.


% 
% iirdes
%
\subsection{{\tt iirdes} (infinite impulse response filter design)}
\label{module:filter:iirdes}
\liquid\ implements infinite impulse response (IIR) filter design for the
five major classes of filters
(Butterworth, Chebyshev type-I, Chebyshev type-II, elliptic, and Bessel)
by
first computing their analog low-pass prototypes, performing a bilinear
$z$-transform to convert to the digital domain, then transforming to the
appropriate band type (e.g. high pass) if necessary.
Externally, the user may abstract the entire process by using the
{\tt liquid\_iirdes()} method.
Furthermore, if the end result is to create a filter {\em object} as
opposed to computing the coefficients themselves, the
{\tt iirfilt\_crcf\_create\_prototype()} method can be used to generate
the object directly
(see \S\ref{module:filter:iirfilt}).

\subsubsection{{\tt liquid\_iirdes()}, the simplified method}
\label{module:filter:iirdes:iirdes}
The {\tt liquid\_iirdes()} method designs an IIR filter's coefficients
from one of the four major types
(Butterworth, Chebyshev, elliptic/Cauer, and Bessel)
with as minimal an interface as possible.
The user specifies the filter prototype, order, cutoff frequency, and
other parameters as well as the resulting filter structure
(regular or second-order sections),
and the function returns the appropriate filter coefficients that meet
that design.
Specifically, the interface is
%
\begin{Verbatim}[fontsize=\small]
    liquid_iirdes(_ftype, _btype, _format, _n, _fc, _f0, _Ap, _As, *_B, *_A);
\end{Verbatim}
%
\begin{description}
\item[{\tt \_ftype}]
    is the analog filter prototype, e.g. {\tt LIQUID\_IIRDES\_BUTTER}
\item[{\tt \_btype}]
    is the band type, e.g. {\tt LIQUID\_IIRDES\_BANDPASS}
\item[{\tt \_format}]
    is the output format of the coefficients, e.g. {\tt LIQUID\_IIRDES\_SOS}
\item[{\tt \_n}]
    is the filter order
\item[{\tt \_fc}]
    is the normalized cutoff frequency of the analog prototype
\item[{\tt \_f0}]
    is the normalized center frequency of the analog prototype (only
    applicable to bandpass and band-stop filter designs, ignored for low-pass
    and high-pass filter designs)
\item[{\tt \_Ap}]
    is the pass-band ripple (only applicable to Chebyshev Type-I and elliptic
    filter designs, ignored for Butterworth, Chebyshev Type-II, and Bessel
    designs)
\item[{\tt \_As}]
    is the stop-band ripple (only applicable to Chebyshev Type-II and elliptic
    filter designs, ignored for Butterworth, Chebyshev Type-I, and Bessel
    designs)
\item[{\tt \_B}, {\tt \_A}]
    are the output feed-forward (numerator) and feed-back (denominator)
    coefficients, respectively.
    The format and size of these arrays depends on the value of the
    {\tt \_format} and {\tt \_btype} parameters.
    To compute the specific lengths of the arrays, first define the
    effective filter order $N$ which is the same as the specified filter
    order for low- and high- pass filters, and doubled for band-pass and
    band-stop filters.
    If the the format is {\tt LIQUID\_IIRDES\_TF}
    (the regular transfer function format)
    then the size of {\tt \_B} and {\tt \_A} is simply $N$.
    If, on the other hand, the format is {\tt LIQUID\_IIRDES\_SOS}
    (second-order sections format) then a few extra steps are needed:
    define $r$ as $0$ when $N$ is even and $1$ when $N$ is odd, and
    define $L$ as $(N-r)/2$.
    The sizes of {\tt \_B} and {\tt \_A} for the second-order sections
    case are each $3(L+r)$.
\end{description}
%
As an example, the following example designs a $5^{th}$-order elliptic
band-pass filter with a bandwidth
%
\input{listings/iirdes.example.c.tex}

\subsubsection{internal description}
\label{module:filter:iirdes:internal}
While the user only needs to specify the filter parameters,
the internal procedure for computing the coefficients is somewhat
complicated.
Listed below is the step-by-step process for \liquid's IIR filter design
procedure.
%
\begin{enumerate}
\item Use {\tt butterf()}, {\tt cheby1f()}, {\tt cheby2f()}, {\tt ellipf()},
      {\tt besself()} to design a low-pass analog prototype $H_a(s)$
      in terms of complex zeros, poles, and gain.
      The {\tt azpkf} extension stands for ``analog zeros, poles, gain
      (floating-point).''

    \begin{description}
    \item[{\tt butter\_azpkf()}] Butterworth (maximally flat in the pass-band)
    \item[{\tt cheby1\_azpkf()}] Chebyshev Type-I (equiripple in the pass-band)
    \item[{\tt cheby2\_azpkf()}] Chebyshev Type-II (equiripple in the stop-band)
    \item[{\tt ellip\_azpkf() }] elliptic filter (equiripple in the pass- and
        stop-bands)
    \item[{\tt bessel\_azpkf()}] Bessel (maximally flat group delay)
    \end{description}

\item Compute frequency pre-warping factor, $m$, to set cutoff frequency (and
      center frequency if designing a band-pass or band-stop filter) using the
      {\tt iirdes\_freqprewarp()} method.

\item Convert the low-pass analog prototype $H_a(s)$ to its digital
      equivalent $H_d(z)$ (also in terms of zeros, poles, and gain)
      using the bilinear $z$-transform using the {\tt bilinear\_zpkf()}
      method.
      This maps the analog zeros/poles/gain into digital
      zeros/poles/gain.

\item Transform the low-pass digital prototype to high-pass, band-pass, or
      band-stop using the {\tt iirdes\_dzpk\_lp2bp()} method.
      For the band-pass and band-stop cases, the number of poles and zeros
      will need to be doubled.
    \begin{description}
    \item[LP] low-pass filter   : $s = m (1+z^{-1}) / (1-z^{-1})$
    \item[HP] high-pass filter  : $s = m (1-z^{-1}) / (1+z^{-1})$
    \item[BP] band-pass filter  : $s = m (1-c_0 z^{-1}+z^{-2}) / (1-z^{-2})$
    \item[BS] band-stop filter  : $s = m (1-z^{-2}) / (1-c_0 z^{-1}+z^{-2})$
    \end{description}

\item Transform the digital $z/p/k$ form of the filter to one of the two forms:
    \begin{description}
    \item[TF]  typical transfer function for digital iir filters of the form
        $B(z)/A(z)$, {\tt iirdes\_dzpk2tff()}
    \item[SOS] second-order sections form : $\prod_k{ B_k(z)/A_k(z) }$, 
        {\tt iirdes\_dzpk2sosf()}.
        This is the preferred method.
    \end{description}

%\item Create the filter object (e.g. iirfilt) from the resulting
%      structure using either {\tt iirfilt\_crcf\_create()} or
%      {\tt iirfilt\_crcf\_create\_sosf()}

\end{enumerate}
%
%An extensive example is given in {\tt sandbox/iirdes\_example.c} while
%{\tt examples/iirdes\_example.c} gives the simplified interface.
A simplified example for this procedure is given in
{\tt examples/iirdes\_example.c}.

\subsubsection{Available Filter Types}
\label{module:filter:iirdes:types}
There are currently five low-pass prototypes available for infinite impulse
response filter design in \liquid, as described below:
%
\begin{description}
\item[{\tt LIQUID\_IIRDES\_BUTTER}]
    is a Butterworth filter.
    This is an all-pole analog design that has a maximally flat magnitude
    response in the pass-band.
    The analog prototype interface is {\tt butter\_azpkf()} which
    computes the $n$ complex roots $p_{a0},p_{a1},\ldots,p_{an-1}$
    of the $n^{th}$-order Butterworth polynomial,
    %
    \begin{equation}
    \label{eqn:filter:iirdes:butter}
        p_{ak} =
            \omega_c \exp\left\{
                j \frac{\left(2k+n+1\right)\pi}{2n}
            \right\}
    \end{equation}
    %
    for $k=0,1,\ldots,n-1$.
    Note that this results in a set of complex conjugate pairs such that
    $(-1)^n s_0 s_1 \cdots s_{n-1} = 1$.
    An example of a digital filter response can be found in
    Figure~\ref{fig:module:filter:butter};
\item[{\tt LIQUID\_IIRDES\_CHEBY1}]
    is a Chebyshev Type-I filter.
    This design uses Chebyshev polynomials to create a filter with a sharper
    transition band than the Butterworth design by allowing ripples in the
    pass-band.
    The analog prototype interface is {\tt cheby1\_azpkf()} which
    computes the $n$ complex roots $p_{ak}$ of the $n^{th}$-order
    Chebyshev polynomial.
    An example of a digital filter response can be found in
    Figure~\ref{fig:module:filter:cheby1};
\item[{\tt LIQUID\_IIRDES\_CHEBY2}]
    is a Chebyshev Type-II filter.
    This design is similar to that of Chebyshev Type-I, except that the
    Chebyshev polynomial is inverted.
    This inverts the magnitude response of the filter and exhibits an
    equiripple behavior in the stop-band, rather than the pass-band.
    The analog prototype interface is {\tt cheby2\_azpkf()}.
    An example of a digital filter response can be found in
    Figure~\ref{fig:module:filter:cheby2}
\item[{\tt LIQUID\_IIRDES\_ELLIP}]
    is an elliptic (Cauer) filter.
    This design allows ripples in both the pass-band and stop-bands to create a
    filter with a very sharp transition band.
    The design process is somewhat more involved than the Butterworth and
    Chebyshev prototypes and requires solving the elliptic integral of
    different moduli.
    For a more detailed description we refer the interested reader to
    \cite{Orfanidis:2006}.
    The analog prototype interface is {\tt ellip\_azpkf()}.
    An example of a digital filter response can be found in
    Figure~\ref{fig:module:filter:ellip};
\item[{\tt LIQUID\_IIRDES\_BESSEL}]
    is a Bessel filter.
    This is an all-pole analog design that has a maximally flat group delay
    response (maximally linear phase response).
    The solution to the design happens to be the roots to the Bessel
    polynomials of equal order.
    Computing the roots to the polynomial is, again, somewhat complex.
    For a more detailed description we refer the interested reader to
    \cite{Orchard:1965}.
    The analog prototype interface is {\tt bessel\_azpkf()}.
    An example of a digital filter response can be found in
    Figure~\ref{fig:module:filter:bessel}.
\end{description}

% 
% bilinear z-transform
%
\subsubsection{{\tt bilinear\_zpkf} (Bilinear $z$-transform)}
\label{module:filter:iirdes:bilinear}
The bilinear $z$-transform converts an analog prototype to its digital
counterpart.
Given a continuous time analog transfer function in zeros/poles/gain
form (``zpk'') with $n_z$ zeros and $n_p$ poles
%\[
%    H(s) =  \frac{
%                r_0 + r_1 s + r_2 s^2 + \cdots + r_n s^n
%            }{
%                q_0 + q_1 s + q_2 s^2 + \cdots + q_m s^m
%            }
%\]
%
\begin{equation}
\label{eqn:filter:iirdes:Ha}
    H_a(s) = k_a
            \frac{
                (s-z_{a0})(s-z_{a1})\cdots(s-z_{an_z-1})
            }{
                (s-p_{a0})(s-p_{a1})\cdots(s-p_{an_p-1})
            }
\end{equation}
%
the bilinear $z$-transform converts $H_a(s)$ into the discrete transfer
function $H_d(z)$ by mapping the $s$-plane onto the $z$-plane with the
approximation
%
\begin{equation}
\label{eqn:filter:iirdes:bilinear}
    s \approx \frac{2}{T}
              \frac{1-z^{-1}}{1 + z^{-1}}
\end{equation}
%
This maps $H_a(0) \rightarrow H_d(0)$ and
$H_a(\infty) \rightarrow H_d(\omega_s/2)$, however we are free to choose
the pre-warping factor which maps the cutoff frequency $\omega_c$.
%
\begin{equation}
\label{eqn:filter:iirdes:bilinear_prewarp}
    s \rightarrow \omega_c
                  \cot\left(\frac{\pi \omega_c}{\omega_s}\right)
                  \frac{1-z^{-1}}{1+z^{-1}}
\end{equation}
%
Substituting this into $H_a(s)$ gives the discrete-time transfer
function
%
\begin{equation}
\label{eqn:filter:iirdes:H}
    H(z) = k_a \frac{
            \left(m\frac{1-z^{-1}}{1+z^{-1}}-z_{a0}\right)
            \left(m\frac{1-z^{-1}}{1+z^{-1}}-z_{a1}\right)
            \cdots
            \left(m\frac{1-z^{-1}}{1+z^{-1}}-z_{an_z-1}\right)
           }{
            \left(m\frac{1-z^{-1}}{1+z^{-1}}-p_{a0}\right)
            \left(m\frac{1-z^{-1}}{1+z^{-1}}-p_{a1}\right)
            \cdots
            \left(m\frac{1-z^{-1}}{1+z^{-1}}-p_{an_p-1}\right)
           }
\end{equation}
%
where $m=\omega_c \cot\left(\pi \omega_c / \omega_s\right)$ is the
frequency pre-warping factor, computed in \liquid\ via the method
{\tt iirdes\_freqprewarp()}.
Multiplying both the numerator an denominator by $(1+z^{-1})^{n_p}$ and
applying some algebraic manipulation results in the digital filter
%
\begin{equation}
\label{eqn:filter:iirdes:Hd}
    H_d(s) = k_d
            \frac{
                (1-z_{d0}z^{-1})(1-z_{d1}z^{-1})\cdots(1-z_{dn-1}z^{-1})
            }{
                (1-p_{d0}z^{-1})(1-p_{d1}z^{-1})\cdots(1-p_{dn-1}z^{-1})
            }
\end{equation}
%
The {\tt bilinear\_zpk()} method in \liquid\ transforms
the the analog zeros ($z_{ak}$),
poles ($p_{ak}$), and gain ($H_0$) into
their digital equivalents
($z_{dk}$, $p_{dk}$, $G_0$).
For a filter with $n_z$ analog zeros $z_{ak}$
the digital zeros $z_{dk}$ are computed as
%
\begin{equation}
\label{eqn:filter:iirdes:bilinear_zeros}
    z_{dk} =
        \begin{cases}
        \frac{1 + m z_{ak}}{1 - m z_{ak}}   & k < n_z \\
        -1                                  & \text{otherwise}
        \end{cases}
\end{equation}
%
where $m$ is the pre-warping factor.
For a filter with $n_p$ analog poles $p_{ak}$
the digital poles $p_{dk}$ are computed as
%
\begin{equation}
\label{eqn:filter:iirdes:bilinear_poles}
    p_{dk} = \frac{1 + m p_{ak}}{1 - m p_{ak}}
\end{equation}
%
Keeping in mind that an analog filter's order is defined by its number
of poles,
the digital gain can be computed as
%
\begin{equation}
\label{eqn:filter:iirdes:bilinear_gain}
    G_0 = H_0 \prod_{k=0}^{n_p-1}{ \frac{1 - p_{dk}}{1 - z_{dk}} }
\end{equation}
%

% 
% filter transformations
%
\subsubsection{Filter transformations}
\label{module:filter:iirdes:transformations}
%
The prototype low-pass digital filter can be converted into a
high-pass, band-pass, or band-stop filter using a combination of the
following filter transformations in \liquid:
%
\begin{description}
\item[{\tt iirdes\_dzpk\_lp2hp(*\_zd,*\_pd,\_n,*\_zdt,*\_pdt)}]
    Converts a low-pass digital prototype $H_d(z)$ to a high-pass
    prototype.
    This is accomplished by transforming the $n$
    zeros and poles
    (represented by the input arrays {\tt \_zd} and {\tt \_pd})
    into $n$ transformed zeros and poles
    (represented by the output arrays {\tt \_zdt} and {\tt \_pdt}).
\item[{\tt iirdes\_dzpk\_lp2bp(*\_zd,*\_pd,\_n,*\_zdt,*\_pdt)}]
    Converts a low-pass digital prototype $H_d(z)$ to a band-pass
    prototype.
    This is accomplished by transforming the $n$
    zeros and poles
    (represented by the input arrays {\tt \_zd} and {\tt \_pd})
    into $2n$ transformed zeros and poles
    (represented by the output arrays {\tt \_zdt} and {\tt \_pdt}).
\end{description}
%
%   LP: LP  ->  LP
%   HP: LP  ->  HP
%   BP: LP  ->  BP
%   BS: LP  ->  HP  ->  BP

% 
% filter coefficient computation
%
\subsubsection{Filter Coefficient Computation}
\label{module:filter:iirdes:coefficients}
%
The digital filter defined by (\ref{eqn:filter:iirdes:Hd}) can be
expanded to fit the familiar IIR transfer function as in
(\ref{eqn:filter:iirfilt:Hz}).
This can be accomplished using the {\tt iirdes\_dzpk2tff()} method.
%
Alternatively, the filter can be written as a set of cascaded
second-order IIR filters:
%
\begin{equation}
\label{eqn:filter:iirfilt:Hd:sos}
    H_d(z) = G_0
             \left[
                \frac{1 + z^{-1}}
                     {1 - p_0 z^{-1}}
             \right]^r
             \prod_{k=1}^{L} {\left[
                G_i \frac{(1-z_iz^{-1})(1-z_i^*z^{-1})}
                         {(1-p_iz^{-1})(1-p_i^*z^{-1})}
             \right]}
\end{equation}
%
where $r=0$ when the filter order is odd, $r=1$ when the filter order is
even, and $L=(n-r)/2$.
This can be accomplished using the {\tt iirdes\_dzpk2sosf()} method and
is preferred over the traditional transfer function design for stability
reasons.

% Butterworth IIR filter design
\begin{figure}
\centering
\subfigure[spectrum] {
  \includegraphics[trim = 0mm 9mm 0mm 10mm, clip, width=0.545\textwidth]{figures.gen/filter_butter_psd}
  }
\subfigure[zeros, poles] {
  \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, width=0.290\textwidth]{figures.gen/filter_butter_zpk}
}
\caption{{\tt butterf} (Butterworth filter design)}
\label{fig:module:filter:butter}
\end{figure}

% Chebyshev type-I IIR filter design
\begin{figure}
\centering
\subfigure[spectrum] {
  \includegraphics[trim = 0mm 9mm 0mm 10mm, clip, width=0.545\textwidth]{figures.gen/filter_cheby1_psd}
}
\subfigure[zeros, poles] {
  \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, width=0.290\textwidth]{figures.gen/filter_cheby1_zpk}
}
\caption{{\tt cheby1f} (Chebyshev type-I filter design)}
\label{fig:module:filter:cheby1}
\end{figure}

% Chebyshev type-II IIR filter design
\begin{figure}
\centering
\subfigure[spectrum] {
  \includegraphics[trim = 0mm 9mm 0mm 10mm, clip, width=0.545\textwidth]{figures.gen/filter_cheby2_psd}
}
\subfigure[zeros, poles] {
  \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, width=0.290\textwidth]{figures.gen/filter_cheby2_zpk}
}
\caption{{\tt cheby2f} (Chebyshev type-II filter design)}
\label{fig:module:filter:cheby2}
\end{figure}

% Elliptic IIR filter design
\begin{figure}
\centering
\subfigure[spectrum] {
  \includegraphics[trim = 0mm 9mm 0mm 10mm, clip, width=0.545\textwidth]{figures.gen/filter_ellip_psd}
}
\subfigure[zeros, poles] {
  \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, width=0.290\textwidth]{figures.gen/filter_ellip_zpk}
}
\caption{{\tt ellipf} (Elliptic filter design)}
\label{fig:module:filter:ellip}
\end{figure}

% Bessel IIR filter design
\begin{figure}
\centering
\subfigure[spectrum] {
  \includegraphics[trim = 0mm 9mm 0mm 10mm, clip, width=0.545\textwidth]{figures.gen/filter_bessel_psd}
}
\subfigure[zeros, poles] {
  \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, width=0.290\textwidth]{figures.gen/filter_bessel_zpk}
}
\caption{{\tt besself} (Bessel filter design)}
\label{fig:module:filter:bessel}
\end{figure}

% 
% interp
%
\subsection{{\tt interp} (interpolator)}
\label{module:filter:interp}
The {\tt interp} object implements a basic interpolator with an integer
output-to-input resampling ratio.
An example of the {\tt interp} interface is listed below.
%
\input{listings/interp.example.c.tex}
%
Listed below is the full interface to the {\tt interp} family of
objects.
While each method is listed for {\tt interp\_crcf}, the same
functionality applies to {\tt interp\_rrrf} and {\tt interp\_cccf}.
%
\begin{description}
\item[{\tt interp\_crcf\_create(M,*h,N)}]
    creates an {\tt interp} object with an interpolation factor $M$
    using $N$ filter coefficients $\vec{h}$.
\item[{\tt interp\_crcf\_create\_prototype(M,m,As)}]
    create an {\tt interp} object using a filter prototype designed
    using the {\tt firdes\_kaiser\_window()} method
    (see \S\ref{module:filter:firdes})
    with a normalized cut-off frequency $1/2M$,
    a filter length of $2Mm$ coefficients,
    and a stop-band attenuation of $A_s$~dB.
\item[{\tt interp\_crcf\_create\_rnyquist(type,k,m,beta,dt)}]
    creates an {\tt interp} object
    from a square-root Nyquist filter prototype with
    $k$ samples per symbol (interpolation factor),
    $m$ symbols of delay,
    $\beta$ excess bandwidth,
    and a fractional sampling interval $\Delta t$.
    \S\ref{module:filter:firdes:rnyquist}
    provides a detailed description of the available square-root Nyquist
    filter prototypes available in \liquid.
\item[{\tt interp\_crcf\_destroy(q)}]
    destroys the interpolator, freeing all internally-allocated memory.
\item[{\tt interp\_crcf\_print(q)}]
    prints the internal properties of the interpolator to the standard
    output.
\item[{\tt interp\_crcf\_clear(q)}]
    clears the internal interpolator buffers.
\item[{\tt interp\_crcf\_execute(q,x,*y)}]
    executes the interpolator for an input $x$, storing the result in
    the output array $y$ (which has a length of $M$ samples).
\end{description}
%
\begin{figure}
\centering
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_interp_crcf}
\caption{{\tt interp\_crcf} (interpolator) example with $M=4$,
         compensating for filter delay.}
\label{fig:module:filter:interp_crcf}
\end{figure}
%
A graphical example of the interpolator can be seen in
Figure~\ref{fig:module:filter:interp_crcf}.
A detailed example program is given in
{\tt examples/interp\_crcf\_example.c},
located under the main \liquid\ project directory.


% 
% msresamp : multi-stage arbitrary resampler
%
\subsection{{\tt msresamp} (multi-stage arbitrary resampler)}
\label{module:filter:msresamp}
The {\tt msresamp} object implements a multi-stage arbitrary resampler
use for efficient interpolation and decimation.
By using a combination of half-band interpolators/decimators
(\S\ref{module:filter:resamp2})
and an arbitrary resampler (\S\ref{module:filter:resamp})
the {\tt msresamp} object can
efficiently realize any arbitrary resampling rate desired.
%
% FIGURE : MSRESAMP DIAGRAMS
%
\begin{figure}
\centering
\subfigure[decimation] {
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=14cm]{figures.pgf/msresamp_decim_diagram}
}
\subfigure[interpolation] {
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=14cm]{figures.pgf/msresamp_interp_diagram}
}
\caption{{\tt msresamp} (multi-stage resampler) block diagram showing
         both interpolation and decimation modes}
\label{fig:module:filter:msresamp_diagram}
\end{figure}
%
Figure~\ref{fig:module:filter:msresamp_diagram} depicts how the
multi-stage resampler operates for both interpolation and decimation
modes.
The half-band resamplers efficiently handle the majority of the work,
leaving the arbitrary resampler to operate at the lowest sample rate
possible.

Listed below is the full interface to the {\tt msresamp} family of
objects.
While each method is listed for {\tt msresamp\_crcf}, the same
functionality applies to {\tt msresamp\_rrrf} and {\tt msresamp\_cccf}.
%
\begin{description}
\item[{\tt msresamp\_crcf\_create(r,As)}]
    creates a {\tt msresamp} object with a resampling rate $r$
    and a target stop-band suppression of $A_s$~dB.
\item[{\tt msresamp\_crcf\_destroy(q)}]
    destroys the resampler, freeing all internally-allocated memory.
\item[{\tt msresamp\_crcf\_print(q)}]
    prints the internal properties of the resampler to the standard
    output.
\item[{\tt msresamp\_crcf\_reset(q)}]
    clears the internal resampler buffers.
\item[{\tt msresamp\_crcf\_filter\_execute(q,*x,nx,*y,*ny)}]
    executes the {\tt msresamp} object on a sample buffer $x$ of length
    $n_x$, storing the output in $y$ and specifying the number of output
    elements in $n_y$.
\item[{\tt msresamp\_crcf\_get\_delay(q)}]
    returns the number of samples of delay in the output
    (can be a non-integer value).
\end{description}
%
Below is a code example demonstrating the {\tt msresamp} interface.
%
\input{listings/msresamp_crcf.example.c.tex}
%
\begin{figure}
\centering
\subfigure[time] {
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_msresamp_crcf_time}
}
\subfigure[PSD] {
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_msresamp_crcf_freq}
}
\caption{{\tt msresamp\_crcf} (multi-stage resampler) interpolator
         demonstration with a stop-band suppression $A_s=60$~dB
         at the irrational rate $r = \sqrt{19} \approx 4.359$}
\label{fig:module:filter:msresamp_crcf}
\end{figure}
%
Figure~\ref{fig:module:filter:msresamp_crcf} gives a graphical depiction
in both the time and frequency domains
of the multi-stage resampler acting as an interpolator.
The time series has been aligned (shifted by the filter delay and scaled by
the resampling rate) to show equivalence.
%
For a more detailed example, refer to
{\tt examples/msresamp\_crcf\_example.c}
located in the main \liquid\ project source directory.


\subsection{{\tt resamp2} (half-band filter/resampler)}
\label{module:filter:resamp2}
{\tt resamp2} is a half-band resampler used for efficient interpolation
and decimation.
The internal filter of the {\tt resamp2} object is a Kaiser-windowed $\sinc$
(see {\tt firdes\_kaiser\_window}, \S\ref{module:filter:firdes}) with
$f_c = 1/2$.
This makes the filter half-band, and puts the half-power (6 dB) cutoff point
$\omega_c$ at $\pi/2$ (one quarter of the sampling frequency).
In fact, any FIR filter design using a windowed $\sinc$ function with
periodicity $f_c=1/2$ will generate a Nyquist half-band filter (zero
inter-symbol interference).
This is because \cite[(4.6.3)]{Vaidyanathan:1993}
%
\begin{equation}
\label{eqn:filter:resamp:h}
    h(Mn) = 
        \begin{cases}
        1 & n=0 \\
        0 & \text{otherwise}
        \end{cases}
\end{equation}
%
which holds for $h(n) = w(n) \sin(\pi n/M) / (\pi n)$ since
$\sin(\pi n/M) = 0$ for $n=$ any non-zero multiple of M.
Additionally, $M=2$ is the special case of half-band filters.
In particular half-band filtering is computationally efficient because half
the coefficients of the filter are zero, and the remaining half are symmetric
(so long as $w(n)$ is also symmetric).
In theory, this means that for a filter length of $4m+1$ taps, only $m$
computations are necessary \cite{harris:2004}.
The {\tt resamp2} object in \liquid\ uses a Kaiser window for $w(n)$ for
several reasons, but in particular because it is nearly optimum, and it is
easy to trade side-lobe attenuation for transition bandwidth.
%
Listed below is the full interface to the {\tt resamp2} family of
objects.
While each method is listed for {\tt resamp2\_crcf}, the same
functionality applies to {\tt resamp2\_rrrf} and {\tt resamp2\_cccf}.
%
\begin{description}
\item[{\tt resamp2\_crcf\_create(m,f0,As)}]
    creates a {\tt resamp2} object with a resampling rate 2,
    a filter semi-length of $m$ samples
    (equivalent filter length $4m+1$),
    centered at frequency $f_0$, and
    a stop-band suppression of $A_s$~dB.
\item[{\tt resamp2\_crcf\_recreate(q,m,f0,As)}]
    recreates a {\tt resamp2} object with revised parameters.
\item[{\tt resamp2\_crcf\_destroy(q)}]
    destroys the resampler, freeing all internally-allocated memory.
\item[{\tt resamp2\_crcf\_print(q)}]
    prints the internal properties of the resampler to the standard
    output.
\item[{\tt resamp2\_crcf\_clear(q)}]
    clears the internal resampler buffers.
\item[{\tt resamp2\_crcf\_filter\_execute(q,x,*y0,*y1)}]
    executes the {\tt resamp2} object as a half-band filter on an input
    sample $x$, storing the low-pass filter output in $y_0$ and the
    high-pass filter output in $y_1$.
\item[{\tt resamp2\_crcf\_decim\_execute(q,*x,*y)}]
    executes the half-band resampler as a decimator
    for an input array $\vec{x}$ with two samples,
    storing the resulting samples in the array $y$.
\item[{\tt resamp2\_crcf\_interp\_execute(q,x,*y)}]
    executes the half-band resampler as an interpolator
    for an input sample $x$,
    storing the resulting two output samples in the array $\vec{y}$.
\end{description}
%
Below is a code example demonstrating the {\tt resamp2} interface.
%
\input{listings/resamp2_crcf.example.c.tex}
%
\begin{figure}
\centering
\subfigure[time] {
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_resamp2_crcf_interp_time}
}
\subfigure[PSD] {
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_resamp2_crcf_interp_freq}
}
\caption{{\tt resamp2\_crcf} (half-band resampler) interpolator demonstration}
\label{fig:module:filter:resamp2_crcf}
\end{figure}
%
Figure~\ref{fig:module:filter:resamp2_crcf} gives a graphical depiction
in both the time and frequency domains
of the half-band resampler acting as an interpolator.
The time series has been aligned (shifted by the filter delay and scaled by
the resampling rate) to show equivalence.
%
For more detailed and extensive examples, refer to
{\tt examples/resamp2\_crcf\_decim\_example.c} and
{\tt examples/resamp2\_crcf\_interp\_example.c}
located in the main \liquid\ project source directory.


% 
% resamp
%
\subsection{{\tt resamp} (arbitrary resampler)}
\label{module:filter:resamp}
For arbitrary (e.g. irrational) resampling ratios, the {\tt resamp}
object is the ideal solution.
It makes no restrictions on the output-to-input resampling ratio
(e.g. irrational values are fair game).
The arbitrary resampler uses a polyphase filter bank for interpolation
between available input sample points.

Because the number of outputs for each input is not fixed, the interface needs
some explaining.
Over time the true resampling ratio will equal the value specified, however
from one input to the next, the number of outputs will change.
For example, if the resampling rate is $2$, every input will produce exactly
two output samples.
However, if the resampling rate is $\sqrt{2} \approx 1.4142$, an input sample
will usually produce one output, but sometimes two.
In the limit (on {\it average}) however, the ratio of output samples to input
samples will be exactly $\sqrt{2}$.
The {\tt resamp} object handles this internally by storing the accumulated
sampling phase and produces an output for each overflow (i.e. values where the
accumulated phase is equal to or exceeds 1).

Below is a code example demonstrating the {\tt resamp} interface.
Notice that the {\tt resamp\_crcf\_execute()} method also returns the number
of samples written to the buffer.
This number will never exceed $\lceil r \rceil$.
%
\input{listings/resamp_crcf.example.c.tex}
%
Figure~\ref{fig:module:filter:resamp_crcf} gives a graphical depiction
of the arbitrary resampler, in both the time and frequency domains.
The time series has been aligned (shifted by the filter delay and scaled by
the resampling rate) to show equivalence.
Additionally, the signal's power spectrum has been scaled by $r$ to reflect
the change in sampling rate.
In the example the input array size is 187 samples;
the resampler produced 133 output samples which yields a true resampling
rate of $\dot{r} = 133/187 \approx 0.71123$ which is close to the target
rate of $r = 1/\sqrt{2} \approx 0.70711$.

It is important to understand how filter design impacts the performance of the
resampler.
The {\tt resamp} object interpolates between available sample points to
minimize aliasing effects on the output signal.
This is apparent in the power spectral density plot in
figure~\ref{fig:module:filter:resamp_crcf} which shows very little aliasing on
the output signal.
Aliasing can be reduced by increasing the filter length at the cost of
additional computational complexity;
additionally the number of filters in the bank can be increased to
improve timing resolution between samples.
For synchronization of digital receivers, it is always good practice to
precede the resampler with an anti-aliasing filter to remove out-of-band
interference.

Listed below is the full interface to the {\tt resamp} family of
objects.
While each method is listed for {\tt resamp\_crcf}, the same
functionality applies to {\tt resamp\_rrrf} and {\tt resamp\_cccf}.
%
\begin{description}
\item[{\tt resamp\_crcf\_create(r,m,fc,As,N)}]
    creates a {\tt resamp} object with a resampling rate $r$,
    a nominal filter delay of $m$ samples, a cutoff frequency of $f_c$,
    a stop-band suppression of $A_s$~dB, using a polyphase filterbank
    with $N$ filters.
\item[{\tt resamp\_crcf\_destroy(q)}]
    destroys the resampler, freeing all internally-allocated memory.
\item[{\tt resamp\_crcf\_print(q)}]
    prints the internal properties of the resampler to the standard
    output.
\item[{\tt resamp\_crcf\_reset(q)}]
    clears the internal resampler buffers.
\item[{\tt resamp\_crcf\_setrate(q,r)}]
    sets the resampling rate to $r$.
\item[{\tt resamp\_crcf\_execute(q,x,*y,*nw)}]
    executes the resampler for an input sample $x$,
    storing the resulting samples in the output array $y$
    specifying the number of samples written as $n_w$.
    The output buffer $y$ needs to be at least $\lceil r \rceil$.
\end{description}
%
{\em See also}: {\tt resamp2}, {\tt firpfb}, {\tt symsync},
{\tt examples/resamp\_crcf\_example.c}

\begin{figure}
\centering
\subfigure[time] {
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_resamp_crcf_time}
}
\subfigure[PSD] {
  \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_resamp_crcf_freq}
}
\caption{
    {\tt resamp\_crcf} (arbitrary resampler) demonstration,
    $r = 1/\sqrt{2} \approx 0.7071$}
\label{fig:module:filter:resamp_crcf}
\end{figure}


% 
% symsync
%
\subsection{{\tt symsync} (symbol synchronizer)}
\label{module:filter:symsync}
The {\tt symsync} object is a multi-rate symbol timing synchronizer
useful for locking a received digital signal to the receiver's clock.
It is effectively the same as the {\tt resamp} object, but includes an
internal control mechanism for tracking to timing phase and frequency
offsets.
The filter structure is a polyphase representation of a Nyquist matched
filter.
%
The instantaneous timing error is computed from the maximum likelihood
timing error detector \cite{Mengali:1997} which relies on the derivative
to the matched filter impulse response.
\liquid\ internally computes polyphase filter banks for both the
matched and derivative-matched filters.
If the output of the matched filter at sample $k$ is $y(k)$
and the output of the derivative matched filter is $\dot{y}(k)$
then the instantaneous timing estimate is
%
\begin{equation}
\label{eqn:filter:symsync:timing_error}
    e_\tau(k) = \tanh\Bigl( y(k)\dot{y}(k) \Bigr)
\end{equation}
%
This timing error estimate has significant improvements over
heuristic-based estimates such as the popular Mueller and M\"{u}ller
timing recovery scheme \cite{Mueller:1976}. % relies on sample spacing
Applying a simple first-order recursive loop filter yields the averaged
timing estimate
%
\begin{equation}
\label{eqn:filter:symsync:timing_error_filtered}
    \Delta\tau(k) = \beta e_\tau(k) + \alpha\Delta\tau(k-1)
\end{equation}
%
where
$\alpha = 1-\omega_\tau$ and $\beta = 0.22\omega_\tau$
are the loop filter coefficients for a given filter bandwidth
$\omega_\tau$.
While these coefficients are certainly not optimized,
it is important to understand the difficulty in computing loop filter
coefficients when a delay is introduced into a control loop.
This delay is the result of the matched filter itself and can cause
instability with traditional phase-locked loop filter designs.
%
Internally the {\tt symsync} object uses the principles of the
{\tt resamp} object
(arbitrary resampler, see \S\ref{module:filter:resamp})
for resampling the signal|actually decimating to one sample per symbol.
Its internal control loop dynamically adjusts the rate $r$ such that
the timing phase of the receiver is aligned with the incoming signal's
symbol timing.

Below is a code example demonstrating the {\tt symsync} interface.
Notice that the {\tt symsync\_crcf\_execute()} method also returns the
number of symbols written to the output buffer.
%
\input{listings/symsync_crcf.example.c.tex}
%
Listed below is the full interface to the {\tt symsync} family of
objects.
While each method is listed for {\tt symsync\_crcf}, the same
functionality applies to {\tt symsync\_rrrf} and {\tt symsync\_cccf}.
%
\begin{description}
\item[{\tt symsync\_crcf\_create(k,N,*h,h\_len)}]
    creates a {\tt symsync} object from a prototype filter $h$ of length
    $h_{len}$ and having $k$ samples per symbol.
    The internal object restructures the input filter into a polyphase
    prototype having $N$ filters.
\item[{\tt symsync\_crcf\_create\_rnyquist(ftype,k,m,beta,N)}]
    creates a {\tt symsync} object from a square-root Nyquist prototype
    of type {\tt ftype} (see \S\ref{module:filter:firdes:rnyquist}
    for a description of available square-root Nyquist filters in
    \liquid).
    The generated filter has $k$ samples per symbol,
    a nominal delay of $m$ symbols, and an excess bandwidth factor of
    $\beta$.
    The internal polyphase filter bank has $N$ filters.
\item[{\tt symsync\_crcf\_destroy(q)}]
    destroys the symbol synchronizer, freeing all internally-allocated
    memory.
\item[{\tt symsync\_crcf\_print(q)}]
    prints the internal properties of the symbol synchronizer object to
    the standard output.
\item[{\tt symsync\_crcf\_clear(q)}]
    resets the symbol synchronizer, clearing the internal buffers and
    filter state.
\item[{\tt symsync\_crcf\_set\_lf\_bw(q,w)}]
    sets the internal bandwidth of the loop filter to $\omega$.
\item[{\tt symsync\_crcf\_lock(q)}]
    locks the symbol synchronizer such that it will still decimate the
    incoming signal but will not update its internal state.
\item[{\tt symsync\_crcf\_unlock(q)}]
    unlocks the symbol synchronizer, resuming its ability to track to
    the input signal.
\item[{\tt symsync\_crcf\_execute(q,*x,nx,*y,*ny)}]
    executes the resampler for an input array $\vec{x}$ with $n_x$
    samples,
    storing the resulting samples in the output array $y$
    specifying the number of samples written as $n_y$.
    %The output buffer $y$ needs to be at least $\lceil r \rceil$.
\item[{\tt symsync\_crcf\_get\_tau(q)}]
    returns the current timing estimate (fractional sampling interval)
    of the object.
\end{description}
%
\begin{figure}
\centering
\subfigure[{\tt symsync} output (time series)] {
    \includegraphics[trim = 0mm 0mm 0mm 0mm, clip, width=13cm]{figures.gen/filter_symsync_crcf_time}
    \label{fig:module:filter:symsync:time}
}
\subfigure[Constellation] {
    \includegraphics[trim = 15mm 0mm 15mm 0mm, clip, width=9cm]{figures.gen/filter_symsync_crcf_const}
    \label{fig:module:filter:symsync:psd}
}
% trim = left bottom right top
\caption{{\tt symsync} (symbol synchronizer) demonstration for a
         QPSK signal with a
         square-root raised-cosine pulse
         with $k=2$ samples/symbol,
         a delay of $m=4$ symbols, and
         an excess bandwidth factor $\beta=0.3$}
\label{fig:module:filter:symsync}
\end{figure}
%
Figure~\ref{fig:module:filter:symsync} demonstrates the
{\tt symsync\_crcf} object recovering the sample timing phase for a QPSK
signal.
%
For a more detailed example, refer to
{\tt examples/symsync\_crcf\_example.c}
located under the main \liquid\ project source directory.

